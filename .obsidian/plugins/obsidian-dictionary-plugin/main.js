/*
THIS IS A GENERATED/BUNDLED FILE BY ROLLUP
if you want to view the source visit the plugins github repository
*/

'use strict';

var obsidian = require('obsidian');

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

/**
 * Transform the case in `value` (`string`) to match that of `base` (`string`).
 *
 * @param {string} value
 * @param {string} base
 * @returns {string}
 */
function matchCasing(value, base) {
  var index = -1;
  /** @type {string} */
  var char;
  /** @type {string} */
  var rest;
  /** @type {boolean} */
  var cap;

  if (base.toUpperCase() === base) {
    return value.toUpperCase()
  }

  if (base.toLowerCase() === base) {
    return value.toLowerCase()
  }

  while (++index < base.length) {
    char = base.charAt(index);

    if (char.toUpperCase() !== char.toLowerCase()) {
      rest = base.slice(index + 1);
      cap = char === char.toUpperCase() && rest === rest.toLowerCase();
      break
    }
  }

  if (cap) {
    index = -1;

    while (++index < value.length) {
      char = value.charAt(index).toUpperCase();

      if (char !== char.toLowerCase()) {
        return (
          value.slice(0, index) + char + value.slice(index + 1).toLowerCase()
        )
      }
    }
  }

  return value
}

// العربية
var ar = {};

// čeština
var cz = {};

// Dansk
var da = {};

// Deutsch
var de = {
    //main.ts
    'Open Dictionary View': 'Öffne Wörterbuch',
    'Open Language Switcher': 'Sprache wechseln',
    //_constants.ts
    'Dictionary': 'Wörterbuch',
    //customContextMenu.ts
    'Cut': 'Ausschneiden',
    'Copy': 'Kopieren',
    'Paste': 'Einfügen',
    'Show Synonyms': 'Zeige Synonyme',
    'Look up': 'Nachschlagen',
    //settingsTab.ts
    'Dictionary Settings': 'Wörterbuch Einstellungen',
    'Language': 'Sprache',
    'The Language the Plugin will use to search for Definitions and Pronunciations.': 'Die Sprache, welche von dieser Erweiterung verwendet wird, um nach Definitionen zu suchen.',
    'Synonym Suggestions': 'Synonym Vorschläge',
    'Show synonyms for highlighted words': 'Zeige Synonyme für markierte Wörter',
    'Enabling this will allow the Plugin to analyze full sentences to better suggest synonyms based on the context.': 'Dies wird der Erweiterung erlauben ganze Sätze zu analysieren, um anschließend bessere Vorschläge für Synonyme basierend auf dem Kontext bereitzustellen.',
    'Click ': 'Klicke ',
    'here': 'hier',
    ' for Privacy Concerns.': ' bei Datenschutzbedenken',
    'Advanced Synonym Search': 'Erweiterte Synonym Suche',
    'Show Options in Context Menu': 'Zeige Optionen im Kontextmenü',
    'Enable custom Context Menu with options to search for synonyms (only if the auto suggestions are disabled) and to look up a full definition in the Sidebar. Warning: This will override Obsidian\'s default Context Menu.': 'Aktiviere das benutzerdefinierte Kontextmenü mit mehr Einstellungen, um Synoynme anzuzeigen (falls die automatischen Vorschläge deaktiviert sind) oder ein Wort nachzuschlagen. Achtung: Dies wird das standard Kontextmenü überschreiben. Um Kompatibilität mit anderen Plugins zu gewährleisten installiere die "Extended Context Menu" Erweiterung.',
    'Click Here': 'Klicke hier',
    'Definition Provider': 'Definitionen Anbieter',
    'The API the Plugin will use to search for Definitions.': 'Die API die von der Erweiterung verwendet werden wird, um Definitionen zu suchen.',
    'Synonym Provider': 'Synonym Anbieter',
    'The API the Plugin will use to search for Synonyms.': 'Die API die von der Erweiterung verwendet werden wird, um Synonyme zu suchen.',
    'More Information': 'Mehr Informationen',
    'View Information about the API\'s and the Plugin itself.': 'Schau dir mehr Informationen über die APIs und die Erweiterung an.',
    'More Info': 'Mehr Infos',
    'Donate': 'Spenden',
    'If you like this Plugin, consider donating to support continued development:': 'Wenn du die Erweiterung hilfreich findest, kannst du hier etwas spenden um die weitere Entwicklung zu unterstützen:',
    'Local Dictionary Folder': 'Ordner für das Lokale Wörterbuch',
    'Specify a Folder, where all new Notes created by the Dictionary are placed. Please note that this Folder needs to already exist.': 'Gebe einen Ordner an, in dem alle vom Wörterbuch erstellten neuen Notizen abgelegt werden. Bitte beachte, dass dieser Ordner bereits vorhanden sein muss.',
    'Capitalize File Name': 'Dateinamen groß schreiben',
    'If you disable this, the names of newly created files will be all lowercase.': 'Wenn dies deaktiviert wird, werden die Namen neu erstellter Dateien nur in Kleinbuchstaben geschrieben.',
    'Filename Prefix and Suffix': 'Dateinamen-Präfix und -Suffix',
    'Here you can add a Prefix and Suffix for your newly created Files.': 'Hier kann ein ein Präfix und ein Suffix für neu erstellte Dateien hinzugefügt werden.',
    "Prefix": "Prefix",
    "Suffix": "Suffix",
    'Here you can edit the Template for newly created Files.': 'Hier kann die Vorlage für neu erstellte Dateien angepasst werden.',
    'Click for a List of Variables': 'Klicke hier für eine Liste aller Variablen.',
    'Template': 'Vorlage',
    "Local-Dictionary-Builder Settings": "Einstellungen für den lokalen Wörterbuch-Builder",
    "Miscellaneous": "Sonstiges",
    //localDictionaryBuilder.ts
    'Autogenerated by Obsidian Dictionary Plugin': 'Automatisch erstellt durch die Wörterbuch Erweiterung',
    //infoModal.svelte
    'API Information': 'API Informationen',
    'Definition API\'s': 'Definitionen APIs',
    'Website': 'Webseite',
    'Synonym API\'s': 'Synonym APIs',
    'Part of Speech API\'s': 'Wortart APIs',
    'This Plugin is using <a href="https://feathericons.com/">Feather Icons</a>': 'Diese Erweiterung verwendet <a href="https://feathericons.com/">Feather Icons</a>',
    //dictionaryView.svelte
    'Enter a word': 'Gebe ein Wort ein',
    'Pronunciation': 'Aussprache',
    'Meanings': 'Bedeutungen',
    'New Note': 'Neue Notiz',
    //errorComponent.ts
    'I can\'t find the word you are looking for or the server can\'t be reached. You can try again in a few minutes.': 'Ich kann das Wort nicht finden oder der Server kann nicht erreicht werden. Bitte probiere es in eingigen Minuten nocheinmal.',
    //meaningComponent.ts
    'Definition:': 'Definition:',
    'Synonyms:': 'Synonyme:',
    //modals
    "Choose a Definition Provider Service": "API für Definitionen auswählen",
    "Choose a Language": "Sprache auswählen",
    "Choose a Synonym Provider Service": "API für Synonyme auswählen",
};

// English
var en = {
    //main.ts
    'Open Dictionary View': 'Open Dictionary View',
    'Open Language Switcher': 'Open Language Switcher',
    //_constants.ts
    'Dictionary': 'Dictionary',
    //customContextMenu.ts
    'Cut': 'Cut',
    'Copy': 'Copy',
    'Paste': 'Paste',
    'Show Synonyms': 'Show Synonyms',
    'Look up': 'Look up',
    //settingsTab.ts
    'Dictionary Settings': 'Dictionary Settings',
    'Language': 'Language',
    'The Language the Plugin will use to search for Definitions and Pronunciations.': 'The Language the Plugin will use to search for Definitions and Pronunciations.',
    'Synonym Suggestions': 'Synonym Suggestions',
    'Show synonyms for highlighted words': 'Show synonyms for highlighted words',
    'Enabling this will allow the Plugin to analyze full sentences to better suggest synonyms based on the context.': 'Enabling this will allow the Plugin to analyze full sentences to better suggest synonyms based on the context.',
    'Click ': 'Click ',
    'here': 'here',
    ' for Privacy Concerns.': ' for Privacy Concerns.',
    'Advanced Synonym Search': 'Advanced Synonym Search',
    'Show Options in Context Menu': 'Show Options in Context Menu',
    'Enable custom Context Menu with options to search for synonyms (only if the auto suggestions are disabled) and to look up a full definition in the Sidebar. Warning: This will override Obsidian\'s default Context Menu.': 'Enable custom Context Menu with options to search for synonyms (only if the auto suggestions are disabled) and to look up a full definition in the Sidebar. Warning: This will override Obsidian\'s default Context Menu. To ensure compatibility with other Plugins please install the "Extended Context Menu" Plugin.',
    'Click Here': 'Click Here',
    'Definition Provider': 'Definition Provider',
    'The API the Plugin will use to search for Definitions.': 'The API the Plugin will use to search for Definitions.',
    'Synonym Provider': 'Synonym Provider',
    'The API the Plugin will use to search for Synonyms.': 'The API the Plugin will use to search for Synonyms.',
    'More Information': 'More Information',
    'View Information about the API\'s and the Plugin itself.': 'View Information about the API\'s and the Plugin itself.',
    'More Info': 'More Info',
    'Donate': 'Donate',
    'If you like this Plugin, consider donating to support continued development:': 'If you like this Plugin, consider donating to support continued development:',
    'Local Dictionary Folder': 'Local Dictionary Folder',
    'Specify a Folder, where all new Notes created by the Dictionary are placed. Please note that this Folder needs to already exist.': 'Specify a Folder, where all new Notes created by the Dictionary are placed. Please note that this Folder needs to already exist.',
    'Capitalize File Name': 'Capitalize File Name',
    'If you disable this, the names of newly created files will be all lowercase.': 'If you disable this, the names of newly created files will be all lowercase.',
    'Filename Prefix and Suffix': 'Filename Prefix and Suffix',
    'Here you can add a Prefix and Suffix for your newly created Files.': 'Here you can add a Prefix and Suffix for your newly created Files.',
    "Prefix": "Prefix",
    "Suffix": "Suffix",
    'Here you can edit the Template for newly created Files.': 'Here you can edit the Template for newly created Files.',
    'Click for a List of Variables': 'Click for a List of Variables',
    'Template': 'Template',
    "Local-Dictionary-Builder Settings": "Local-Dictionary-Builder Settings",
    "Miscellaneous": "Miscellaneous",
    //localDictionaryBuilder.ts
    'Autogenerated by Obsidian Dictionary Plugin': 'Autogenerated by Obsidian Dictionary Plugin',
    //infoModal.svelte
    'API Information': 'API Information',
    'Definition API\'s': 'Definition API\'s',
    'Website': 'Website',
    'Synonym API\'s': 'Synonym API\'s',
    'Part of Speech API\'s': 'Part of Speech API\'s',
    'This Plugin is using <a href="https://feathericons.com/">Feather Icons</a>': 'This Plugin is using <a href="https://feathericons.com/">Feather Icons</a>',
    //dictionaryView.svelte
    'Enter a word': 'Enter a word',
    'Pronunciation': 'Pronunciation',
    'Meanings': 'Meanings',
    'New Note': 'New Note',
    //errorComponent.ts
    'I can\'t find the word you are looking for or the server can\'t be reached. You can try again in a few minutes.': 'I can\'t find the word you are looking for or the server can\'t be reached. You can try again in a few minutes.',
    //meaningComponent.ts
    'Definition:': 'Definition:',
    'Synonyms:': 'Synonyms:',
    //modals
    "Choose a Definition Provider Service": "Choose a Definition Provider Service",
    "Choose a Language": "Choose a Language",
    "Choose a Synonym Provider Service": "Choose a Synonym Provider Service",
};

// British English
var enGB = {};

// Español
var es = {};

// français
var fr = {};

// हिन्दी
var hi = {};

// Bahasa Indonesia
var id = {};

// Italiano
var it = {};

// 日本語
var ja = {};

// 한국어
var ko = {};

// Nederlands
var nl = {};

// Norsk
var no = {};

// język polski
var pl = {};

// Português
var pt = {};

// Português do Brasil
// Brazilian Portuguese
var ptBR = {};

// Română
var ro = {};

// русский
var ru = {};

// Türkçe
var tr = {};

// 简体中文
var zhCN = {
    //main.ts
    'Open Dictionary View': '打开查词面板',
    //_constants.ts
    'Dictionary': '词典',
    //customContextMenu.ts
    'Cut': '剪切',
    'Copy': '复制',
    'Paste': '粘贴',
    'Show Synonyms': '显示同义词',
    'Look up': '查询',
    //settingsTab.ts
    'Dictionary Settings': '词典设置',
    'Language': '语言',
    'The Language the Plugin will use to search for Definitions and Pronunciations.': '插件会根据该语言来搜索语义以及发音',
    'Synonym Suggestions': '同义词建议',
    'Show synonyms for highlighted words': '展示被高亮的词的同义词',
    'Enabling this will allow the Plugin to analyze full sentences to better suggest synonyms based on the context.': '允许该选项将会对整段文本进行分析来建议更好的同义词',
    'Click ': '点击 ',
    'here': '这里',
    ' for Privacy Concerns.': ' 来获取相关隐私解释',
    'Advanced Synonym Search': '同义词搜索进阶',
    'Show Options in Context Menu': '在右键菜单中显示选项',
    'Enable custom Context Menu with options to search for synonyms (only if the auto suggestions are disabled) and to look up a full definition in the Sidebar. Warning: This will override Obsidian\'s default Context Menu.': '允许自定义右键菜单来更方便搜索同义词（需要关闭自动建议）且在侧栏的词典面板展示相关释义。注意，这会覆盖掉 Obsidian 的默认右键菜单。',
    'Definition Provider': '释义来源',
    'The API the Plugin will use to search for Definitions.': '将基于该 API 去搜索释义',
    'Synonym Provider': '同义词来源',
    'The API the Plugin will use to search for Synonyms.': '将基于该 API 去搜索同义词',
    'More Information': '更多信息',
    'View Information about the API\'s and the Plugin itself.': '了解关于插件以及 API 的信息',
    'More Info': '更多信息',
    'Donate': '捐赠',
    'If you like this Plugin, consider donating to support continued development:': '如果你喜欢该插件，可以考虑打赏支持：',
    'Local Dictionary Folder': '本地词典文件夹',
    'Specify a Folder, where all new Notes created by the Dictionary are placed. Please note that this Folder needs to already exist.': '指定词典创建的新笔记所存放的位置，注意文件夹需要存在',
    //localDictionaryBuilder.ts
    'Autogenerated by Obsidian Dictionary Plugin': '由 Obsidian Dictionary Plugin 插件自动生成',
    //infoModal.svelte
    'API Information': 'API 信息',
    'Definition API\'s': '定义 API',
    'Website': '网站',
    'Synonym API\'s': '定义同义词 API',
    'Part of Speech API\'s': '语音 API',
    'This Plugin is using <a href="https://feathericons.com/">Feather Icons</a>': '这个插件使用 <a href="https://feathericons.com/">Feather 图标</a>',
    //dictionaryView.svelte
    'Enter a word': '输入单词',
    'Pronunciation': '发音',
    'Meanings': '词义',
    'New Note': '新笔记',
    //errorComponent.ts
    'I can\'t find the word you are looking for or the server can\'t be reached. You can try again in a few minutes.': '无法找到你搜索的单词或者服务器当前不可用，你可以几分钟后再试一下。',
    //meaningComponent.ts
    'Definition:': '词义：',
    'Synonyms:': '同义词：',
};

// 繁體中文
var zhTW = {};

const localeMap = {
    ar,
    cs: cz,
    da,
    de,
    en,
    "en-gb": enGB,
    es,
    fr,
    hi,
    id,
    it,
    ja,
    ko,
    nl,
    nn: no,
    pl,
    pt,
    "pt-br": ptBR,
    ro,
    ru,
    tr,
    "zh-cn": zhCN,
    "zh-tw": zhTW,
};
const locale = localeMap[obsidian.moment.locale()];
function t(str) {
    if (!locale) {
        console.error("Error: dictionary locale not found", obsidian.moment.locale());
    }
    return (locale && locale[str]) || en[str];
}

const VIEW_TYPE = 'dictionary-view';
const VIEW_DISPLAY_TEXT = t('Dictionary');
const VIEW_ICON = 'quote-glyph';
const LANGUAGES = {
    "en_US": "English (US)",
    "hi": "Hindi",
    "es": "Spanish",
    "fr": "French",
    "ja": "Japanese",
    "ru": "Russian",
    "en_GB": "English (UK)",
    "de": "German",
    "it": "Italian",
    "ko": "Korean",
    "pt-BR": "Brazilian Portuguese",
    "ar": "Arabic",
    "tr": "Turkish"
};
const DEFAULT_SETTINGS = {
    defaultLanguage: "en_US",
    shouldShowSynonymPopover: true,
    shouldShowCustomContextMenu: false,
    definitionApiName: "Free Dictionary API",
    synonymApiName: "Free Dictionary API",
    partOfSpeechApiName: "Systran API",
    advancedSynonymAnalysis: false,
    folder: '',
    capitalizedFileName: true,
    prefix: "",
    suffix: "",
    template: `---
# {{notice}}
---

# {{word}}

## {{pronunciationHeader}}

{{phoneticList}}

## {{meaningHeader}}

{{meanings}}
`,
};

function noop() { }
const identity = x => x;
function is_promise(value) {
    return value && typeof value === 'object' && typeof value.then === 'function';
}
function run(fn) {
    return fn();
}
function blank_object() {
    return Object.create(null);
}
function run_all(fns) {
    fns.forEach(run);
}
function is_function(thing) {
    return typeof thing === 'function';
}
function safe_not_equal(a, b) {
    return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
}
function is_empty(obj) {
    return Object.keys(obj).length === 0;
}
function action_destroyer(action_result) {
    return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;
}

const is_client = typeof window !== 'undefined';
let now = is_client
    ? () => window.performance.now()
    : () => Date.now();
let raf = is_client ? cb => requestAnimationFrame(cb) : noop;

const tasks = new Set();
function run_tasks(now) {
    tasks.forEach(task => {
        if (!task.c(now)) {
            tasks.delete(task);
            task.f();
        }
    });
    if (tasks.size !== 0)
        raf(run_tasks);
}
/**
 * Creates a new task that runs on each raf frame
 * until it returns a falsy value or is aborted
 */
function loop(callback) {
    let task;
    if (tasks.size === 0)
        raf(run_tasks);
    return {
        promise: new Promise(fulfill => {
            tasks.add(task = { c: callback, f: fulfill });
        }),
        abort() {
            tasks.delete(task);
        }
    };
}

function append(target, node) {
    target.appendChild(node);
}
function insert(target, node, anchor) {
    target.insertBefore(node, anchor || null);
}
function detach(node) {
    node.parentNode.removeChild(node);
}
function destroy_each(iterations, detaching) {
    for (let i = 0; i < iterations.length; i += 1) {
        if (iterations[i])
            iterations[i].d(detaching);
    }
}
function element(name) {
    return document.createElement(name);
}
function text(data) {
    return document.createTextNode(data);
}
function space() {
    return text(' ');
}
function empty() {
    return text('');
}
function listen(node, event, handler, options) {
    node.addEventListener(event, handler, options);
    return () => node.removeEventListener(event, handler, options);
}
function attr(node, attribute, value) {
    if (value == null)
        node.removeAttribute(attribute);
    else if (node.getAttribute(attribute) !== value)
        node.setAttribute(attribute, value);
}
function children(element) {
    return Array.from(element.childNodes);
}
function set_data(text, data) {
    data = '' + data;
    if (text.wholeText !== data)
        text.data = data;
}
function set_input_value(input, value) {
    input.value = value == null ? '' : value;
}
function set_style(node, key, value, important) {
    node.style.setProperty(key, value, important ? 'important' : '');
}
function custom_event(type, detail) {
    const e = document.createEvent('CustomEvent');
    e.initCustomEvent(type, false, false, detail);
    return e;
}

const active_docs = new Set();
let active = 0;
// https://github.com/darkskyapp/string-hash/blob/master/index.js
function hash(str) {
    let hash = 5381;
    let i = str.length;
    while (i--)
        hash = ((hash << 5) - hash) ^ str.charCodeAt(i);
    return hash >>> 0;
}
function create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {
    const step = 16.666 / duration;
    let keyframes = '{\n';
    for (let p = 0; p <= 1; p += step) {
        const t = a + (b - a) * ease(p);
        keyframes += p * 100 + `%{${fn(t, 1 - t)}}\n`;
    }
    const rule = keyframes + `100% {${fn(b, 1 - b)}}\n}`;
    const name = `__svelte_${hash(rule)}_${uid}`;
    const doc = node.ownerDocument;
    active_docs.add(doc);
    const stylesheet = doc.__svelte_stylesheet || (doc.__svelte_stylesheet = doc.head.appendChild(element('style')).sheet);
    const current_rules = doc.__svelte_rules || (doc.__svelte_rules = {});
    if (!current_rules[name]) {
        current_rules[name] = true;
        stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);
    }
    const animation = node.style.animation || '';
    node.style.animation = `${animation ? `${animation}, ` : ''}${name} ${duration}ms linear ${delay}ms 1 both`;
    active += 1;
    return name;
}
function delete_rule(node, name) {
    const previous = (node.style.animation || '').split(', ');
    const next = previous.filter(name
        ? anim => anim.indexOf(name) < 0 // remove specific animation
        : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations
    );
    const deleted = previous.length - next.length;
    if (deleted) {
        node.style.animation = next.join(', ');
        active -= deleted;
        if (!active)
            clear_rules();
    }
}
function clear_rules() {
    raf(() => {
        if (active)
            return;
        active_docs.forEach(doc => {
            const stylesheet = doc.__svelte_stylesheet;
            let i = stylesheet.cssRules.length;
            while (i--)
                stylesheet.deleteRule(i);
            doc.__svelte_rules = {};
        });
        active_docs.clear();
    });
}

let current_component;
function set_current_component(component) {
    current_component = component;
}
function get_current_component() {
    if (!current_component)
        throw new Error('Function called outside component initialization');
    return current_component;
}

const dirty_components = [];
const binding_callbacks = [];
const render_callbacks = [];
const flush_callbacks = [];
const resolved_promise = Promise.resolve();
let update_scheduled = false;
function schedule_update() {
    if (!update_scheduled) {
        update_scheduled = true;
        resolved_promise.then(flush);
    }
}
function add_render_callback(fn) {
    render_callbacks.push(fn);
}
let flushing = false;
const seen_callbacks = new Set();
function flush() {
    if (flushing)
        return;
    flushing = true;
    do {
        // first, call beforeUpdate functions
        // and update components
        for (let i = 0; i < dirty_components.length; i += 1) {
            const component = dirty_components[i];
            set_current_component(component);
            update(component.$$);
        }
        set_current_component(null);
        dirty_components.length = 0;
        while (binding_callbacks.length)
            binding_callbacks.pop()();
        // then, once components are updated, call
        // afterUpdate functions. This may cause
        // subsequent updates...
        for (let i = 0; i < render_callbacks.length; i += 1) {
            const callback = render_callbacks[i];
            if (!seen_callbacks.has(callback)) {
                // ...so guard against infinite loops
                seen_callbacks.add(callback);
                callback();
            }
        }
        render_callbacks.length = 0;
    } while (dirty_components.length);
    while (flush_callbacks.length) {
        flush_callbacks.pop()();
    }
    update_scheduled = false;
    flushing = false;
    seen_callbacks.clear();
}
function update($$) {
    if ($$.fragment !== null) {
        $$.update();
        run_all($$.before_update);
        const dirty = $$.dirty;
        $$.dirty = [-1];
        $$.fragment && $$.fragment.p($$.ctx, dirty);
        $$.after_update.forEach(add_render_callback);
    }
}

let promise;
function wait() {
    if (!promise) {
        promise = Promise.resolve();
        promise.then(() => {
            promise = null;
        });
    }
    return promise;
}
function dispatch(node, direction, kind) {
    node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));
}
const outroing = new Set();
let outros;
function group_outros() {
    outros = {
        r: 0,
        c: [],
        p: outros // parent group
    };
}
function check_outros() {
    if (!outros.r) {
        run_all(outros.c);
    }
    outros = outros.p;
}
function transition_in(block, local) {
    if (block && block.i) {
        outroing.delete(block);
        block.i(local);
    }
}
function transition_out(block, local, detach, callback) {
    if (block && block.o) {
        if (outroing.has(block))
            return;
        outroing.add(block);
        outros.c.push(() => {
            outroing.delete(block);
            if (callback) {
                if (detach)
                    block.d(1);
                callback();
            }
        });
        block.o(local);
    }
}
const null_transition = { duration: 0 };
function create_in_transition(node, fn, params) {
    let config = fn(node, params);
    let running = false;
    let animation_name;
    let task;
    let uid = 0;
    function cleanup() {
        if (animation_name)
            delete_rule(node, animation_name);
    }
    function go() {
        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;
        if (css)
            animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);
        tick(0, 1);
        const start_time = now() + delay;
        const end_time = start_time + duration;
        if (task)
            task.abort();
        running = true;
        add_render_callback(() => dispatch(node, true, 'start'));
        task = loop(now => {
            if (running) {
                if (now >= end_time) {
                    tick(1, 0);
                    dispatch(node, true, 'end');
                    cleanup();
                    return running = false;
                }
                if (now >= start_time) {
                    const t = easing((now - start_time) / duration);
                    tick(t, 1 - t);
                }
            }
            return running;
        });
    }
    let started = false;
    return {
        start() {
            if (started)
                return;
            delete_rule(node);
            if (is_function(config)) {
                config = config();
                wait().then(go);
            }
            else {
                go();
            }
        },
        invalidate() {
            started = false;
        },
        end() {
            if (running) {
                cleanup();
                running = false;
            }
        }
    };
}

function handle_promise(promise, info) {
    const token = info.token = {};
    function update(type, index, key, value) {
        if (info.token !== token)
            return;
        info.resolved = value;
        let child_ctx = info.ctx;
        if (key !== undefined) {
            child_ctx = child_ctx.slice();
            child_ctx[key] = value;
        }
        const block = type && (info.current = type)(child_ctx);
        let needs_flush = false;
        if (info.block) {
            if (info.blocks) {
                info.blocks.forEach((block, i) => {
                    if (i !== index && block) {
                        group_outros();
                        transition_out(block, 1, 1, () => {
                            if (info.blocks[i] === block) {
                                info.blocks[i] = null;
                            }
                        });
                        check_outros();
                    }
                });
            }
            else {
                info.block.d(1);
            }
            block.c();
            transition_in(block, 1);
            block.m(info.mount(), info.anchor);
            needs_flush = true;
        }
        info.block = block;
        if (info.blocks)
            info.blocks[index] = block;
        if (needs_flush) {
            flush();
        }
    }
    if (is_promise(promise)) {
        const current_component = get_current_component();
        promise.then(value => {
            set_current_component(current_component);
            update(info.then, 1, info.value, value);
            set_current_component(null);
        }, error => {
            set_current_component(current_component);
            update(info.catch, 2, info.error, error);
            set_current_component(null);
            if (!info.hasCatch) {
                throw error;
            }
        });
        // if we previously had a then/catch block, destroy it
        if (info.current !== info.pending) {
            update(info.pending, 0);
            return true;
        }
    }
    else {
        if (info.current !== info.then) {
            update(info.then, 1, info.value, promise);
            return true;
        }
        info.resolved = promise;
    }
}
function update_await_block_branch(info, ctx, dirty) {
    const child_ctx = ctx.slice();
    const { resolved } = info;
    if (info.current === info.then) {
        child_ctx[info.value] = resolved;
    }
    if (info.current === info.catch) {
        child_ctx[info.error] = resolved;
    }
    info.block.p(child_ctx, dirty);
}

const globals = (typeof window !== 'undefined'
    ? window
    : typeof globalThis !== 'undefined'
        ? globalThis
        : global);
function create_component(block) {
    block && block.c();
}
function mount_component(component, target, anchor, customElement) {
    const { fragment, on_mount, on_destroy, after_update } = component.$$;
    fragment && fragment.m(target, anchor);
    if (!customElement) {
        // onMount happens before the initial afterUpdate
        add_render_callback(() => {
            const new_on_destroy = on_mount.map(run).filter(is_function);
            if (on_destroy) {
                on_destroy.push(...new_on_destroy);
            }
            else {
                // Edge case - component was destroyed immediately,
                // most likely as a result of a binding initialising
                run_all(new_on_destroy);
            }
            component.$$.on_mount = [];
        });
    }
    after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
    const $$ = component.$$;
    if ($$.fragment !== null) {
        run_all($$.on_destroy);
        $$.fragment && $$.fragment.d(detaching);
        // TODO null out other refs, including component.$$ (but need to
        // preserve final state?)
        $$.on_destroy = $$.fragment = null;
        $$.ctx = [];
    }
}
function make_dirty(component, i) {
    if (component.$$.dirty[0] === -1) {
        dirty_components.push(component);
        schedule_update();
        component.$$.dirty.fill(0);
    }
    component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));
}
function init(component, options, instance, create_fragment, not_equal, props, dirty = [-1]) {
    const parent_component = current_component;
    set_current_component(component);
    const $$ = component.$$ = {
        fragment: null,
        ctx: null,
        // state
        props,
        update: noop,
        not_equal,
        bound: blank_object(),
        // lifecycle
        on_mount: [],
        on_destroy: [],
        on_disconnect: [],
        before_update: [],
        after_update: [],
        context: new Map(parent_component ? parent_component.$$.context : options.context || []),
        // everything else
        callbacks: blank_object(),
        dirty,
        skip_bound: false
    };
    let ready = false;
    $$.ctx = instance
        ? instance(component, options.props || {}, (i, ret, ...rest) => {
            const value = rest.length ? rest[0] : ret;
            if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
                if (!$$.skip_bound && $$.bound[i])
                    $$.bound[i](value);
                if (ready)
                    make_dirty(component, i);
            }
            return ret;
        })
        : [];
    $$.update();
    ready = true;
    run_all($$.before_update);
    // `false` as a special case of no DOM component
    $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
    if (options.target) {
        if (options.hydrate) {
            const nodes = children(options.target);
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            $$.fragment && $$.fragment.l(nodes);
            nodes.forEach(detach);
        }
        else {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            $$.fragment && $$.fragment.c();
        }
        if (options.intro)
            transition_in(component.$$.fragment);
        mount_component(component, options.target, options.anchor, options.customElement);
        flush();
    }
    set_current_component(parent_component);
}
/**
 * Base class for Svelte components. Used when dev=false.
 */
class SvelteComponent {
    $destroy() {
        destroy_component(this, 1);
        this.$destroy = noop;
    }
    $on(type, callback) {
        const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
        callbacks.push(callback);
        return () => {
            const index = callbacks.indexOf(callback);
            if (index !== -1)
                callbacks.splice(index, 1);
        };
    }
    $set($$props) {
        if (this.$$set && !is_empty($$props)) {
            this.$$.skip_bound = true;
            this.$$set($$props);
            this.$$.skip_bound = false;
        }
    }
}

/* src/ui/settings/infoModal.svelte generated by Svelte v3.38.2 */

function add_css$5() {
	var style = element("style");
	style.id = "svelte-ja9vc4-style";
	style.textContent = "h3.svelte-ja9vc4{font-weight:400;margin:0}.feather.svelte-ja9vc4{text-align:center;color:var(--text-muted);font-size:0.9rem}";
	append(document.head, style);
}

function get_each_context$3(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[3] = list[i];
	return child_ctx;
}

function get_each_context_1$2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[6] = list[i];
	return child_ctx;
}

function get_each_context_2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[9] = list[i];
	return child_ctx;
}

// (12:2) {#each definitionAPIs as definition}
function create_each_block_2(ctx) {
	let div2;
	let div1;
	let div0;
	let t0_value = /*definition*/ ctx[9].name + "";
	let t0;
	let t1;
	let a;
	let t2_value = t("Website") + "";
	let t2;
	let a_href_value;

	return {
		c() {
			div2 = element("div");
			div1 = element("div");
			div0 = element("div");
			t0 = text(t0_value);
			t1 = space();
			a = element("a");
			t2 = text(t2_value);
			attr(div0, "class", "setting-item-name");
			attr(div1, "class", "setting-item-info");
			attr(a, "class", "setting-item-control");
			attr(a, "href", a_href_value = /*definition*/ ctx[9].url);
			attr(div2, "class", "setting-item");
		},
		m(target, anchor) {
			insert(target, div2, anchor);
			append(div2, div1);
			append(div1, div0);
			append(div0, t0);
			append(div2, t1);
			append(div2, a);
			append(a, t2);
		},
		p(ctx, dirty) {
			if (dirty & /*definitionAPIs*/ 2 && t0_value !== (t0_value = /*definition*/ ctx[9].name + "")) set_data(t0, t0_value);

			if (dirty & /*definitionAPIs*/ 2 && a_href_value !== (a_href_value = /*definition*/ ctx[9].url)) {
				attr(a, "href", a_href_value);
			}
		},
		d(detaching) {
			if (detaching) detach(div2);
		}
	};
}

// (23:2) {#each synonymAPIs as synonym}
function create_each_block_1$2(ctx) {
	let div2;
	let div1;
	let div0;
	let t0_value = /*synonym*/ ctx[6].name + "";
	let t0;
	let t1;
	let a;
	let t2_value = t("Website") + "";
	let t2;
	let a_href_value;

	return {
		c() {
			div2 = element("div");
			div1 = element("div");
			div0 = element("div");
			t0 = text(t0_value);
			t1 = space();
			a = element("a");
			t2 = text(t2_value);
			attr(div0, "class", "setting-item-name");
			attr(div1, "class", "setting-item-info");
			attr(a, "class", "setting-item-control");
			attr(a, "href", a_href_value = /*synonym*/ ctx[6].url);
			attr(div2, "class", "setting-item");
		},
		m(target, anchor) {
			insert(target, div2, anchor);
			append(div2, div1);
			append(div1, div0);
			append(div0, t0);
			append(div2, t1);
			append(div2, a);
			append(a, t2);
		},
		p(ctx, dirty) {
			if (dirty & /*synonymAPIs*/ 1 && t0_value !== (t0_value = /*synonym*/ ctx[6].name + "")) set_data(t0, t0_value);

			if (dirty & /*synonymAPIs*/ 1 && a_href_value !== (a_href_value = /*synonym*/ ctx[6].url)) {
				attr(a, "href", a_href_value);
			}
		},
		d(detaching) {
			if (detaching) detach(div2);
		}
	};
}

// (34:2) {#each partOfSpeechAPIs as pos}
function create_each_block$3(ctx) {
	let div2;
	let div1;
	let div0;
	let t0_value = /*pos*/ ctx[3].name + "";
	let t0;
	let t1;
	let a;
	let t2_value = t("Website") + "";
	let t2;
	let a_href_value;
	let t3;

	return {
		c() {
			div2 = element("div");
			div1 = element("div");
			div0 = element("div");
			t0 = text(t0_value);
			t1 = space();
			a = element("a");
			t2 = text(t2_value);
			t3 = space();
			attr(div0, "class", "setting-item-name");
			attr(div1, "class", "setting-item-info");
			attr(a, "class", "setting-item-control");
			attr(a, "href", a_href_value = /*pos*/ ctx[3].url);
			attr(div2, "class", "setting-item");
		},
		m(target, anchor) {
			insert(target, div2, anchor);
			append(div2, div1);
			append(div1, div0);
			append(div0, t0);
			append(div2, t1);
			append(div2, a);
			append(a, t2);
			append(div2, t3);
		},
		p(ctx, dirty) {
			if (dirty & /*partOfSpeechAPIs*/ 4 && t0_value !== (t0_value = /*pos*/ ctx[3].name + "")) set_data(t0, t0_value);

			if (dirty & /*partOfSpeechAPIs*/ 4 && a_href_value !== (a_href_value = /*pos*/ ctx[3].url)) {
				attr(a, "href", a_href_value);
			}
		},
		d(detaching) {
			if (detaching) detach(div2);
		}
	};
}

function create_fragment$5(ctx) {
	let div;
	let h2;
	let t1;
	let h30;
	let t3;
	let t4;
	let h31;
	let t6;
	let t7;
	let h32;
	let t9;
	let t10;
	let p;
	let raw_value = t("This Plugin is using <a href=\"https://feathericons.com/\">Feather Icons</a>") + "";
	let each_value_2 = /*definitionAPIs*/ ctx[1];
	let each_blocks_2 = [];

	for (let i = 0; i < each_value_2.length; i += 1) {
		each_blocks_2[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
	}

	let each_value_1 = /*synonymAPIs*/ ctx[0];
	let each_blocks_1 = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks_1[i] = create_each_block_1$2(get_each_context_1$2(ctx, each_value_1, i));
	}

	let each_value = /*partOfSpeechAPIs*/ ctx[2];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$3(get_each_context$3(ctx, each_value, i));
	}

	return {
		c() {
			div = element("div");
			h2 = element("h2");
			h2.textContent = `${t("API Information")}`;
			t1 = space();
			h30 = element("h3");
			h30.textContent = `${t("Definition API's")}`;
			t3 = space();

			for (let i = 0; i < each_blocks_2.length; i += 1) {
				each_blocks_2[i].c();
			}

			t4 = space();
			h31 = element("h3");
			h31.textContent = `${t("Synonym API's")}`;
			t6 = space();

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].c();
			}

			t7 = space();
			h32 = element("h3");
			h32.textContent = `${t("Part of Speech API's")}`;
			t9 = space();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t10 = space();
			p = element("p");
			attr(h30, "class", "svelte-ja9vc4");
			attr(h31, "class", "svelte-ja9vc4");
			attr(h32, "class", "svelte-ja9vc4");
			attr(div, "class", "vertical-tab-content");
			attr(p, "class", "feather svelte-ja9vc4");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, h2);
			append(div, t1);
			append(div, h30);
			append(div, t3);

			for (let i = 0; i < each_blocks_2.length; i += 1) {
				each_blocks_2[i].m(div, null);
			}

			append(div, t4);
			append(div, h31);
			append(div, t6);

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].m(div, null);
			}

			append(div, t7);
			append(div, h32);
			append(div, t9);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div, null);
			}

			insert(target, t10, anchor);
			insert(target, p, anchor);
			p.innerHTML = raw_value;
		},
		p(ctx, [dirty]) {
			if (dirty & /*definitionAPIs, t*/ 2) {
				each_value_2 = /*definitionAPIs*/ ctx[1];
				let i;

				for (i = 0; i < each_value_2.length; i += 1) {
					const child_ctx = get_each_context_2(ctx, each_value_2, i);

					if (each_blocks_2[i]) {
						each_blocks_2[i].p(child_ctx, dirty);
					} else {
						each_blocks_2[i] = create_each_block_2(child_ctx);
						each_blocks_2[i].c();
						each_blocks_2[i].m(div, t4);
					}
				}

				for (; i < each_blocks_2.length; i += 1) {
					each_blocks_2[i].d(1);
				}

				each_blocks_2.length = each_value_2.length;
			}

			if (dirty & /*synonymAPIs, t*/ 1) {
				each_value_1 = /*synonymAPIs*/ ctx[0];
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1$2(ctx, each_value_1, i);

					if (each_blocks_1[i]) {
						each_blocks_1[i].p(child_ctx, dirty);
					} else {
						each_blocks_1[i] = create_each_block_1$2(child_ctx);
						each_blocks_1[i].c();
						each_blocks_1[i].m(div, t7);
					}
				}

				for (; i < each_blocks_1.length; i += 1) {
					each_blocks_1[i].d(1);
				}

				each_blocks_1.length = each_value_1.length;
			}

			if (dirty & /*partOfSpeechAPIs, t*/ 4) {
				each_value = /*partOfSpeechAPIs*/ ctx[2];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$3(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$3(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div);
			destroy_each(each_blocks_2, detaching);
			destroy_each(each_blocks_1, detaching);
			destroy_each(each_blocks, detaching);
			if (detaching) detach(t10);
			if (detaching) detach(p);
		}
	};
}

function instance$5($$self, $$props, $$invalidate) {
	
	let { synonymAPIs } = $$props;
	let { definitionAPIs } = $$props;
	let { partOfSpeechAPIs } = $$props;

	$$self.$$set = $$props => {
		if ("synonymAPIs" in $$props) $$invalidate(0, synonymAPIs = $$props.synonymAPIs);
		if ("definitionAPIs" in $$props) $$invalidate(1, definitionAPIs = $$props.definitionAPIs);
		if ("partOfSpeechAPIs" in $$props) $$invalidate(2, partOfSpeechAPIs = $$props.partOfSpeechAPIs);
	};

	return [synonymAPIs, definitionAPIs, partOfSpeechAPIs];
}

class InfoModal$1 extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-ja9vc4-style")) add_css$5();

		init(this, options, instance$5, create_fragment$5, safe_not_equal, {
			synonymAPIs: 0,
			definitionAPIs: 1,
			partOfSpeechAPIs: 2
		});
	}
}

class SettingsTab extends obsidian.PluginSettingTab {
    constructor(app, plugin) {
        super(app, plugin);
        this.plugin = plugin;
    }
    display() {
        const { containerEl, plugin } = this;
        containerEl.empty();
        containerEl.createEl('h2', { text: t('Dictionary Settings') });
        new obsidian.Setting(containerEl)
            .setName(t('Language'))
            .setDesc(t('The Language the Plugin will use to search for Definitions and Pronunciations.'))
            .addDropdown((dropdown) => {
            for (const language in LANGUAGES) {
                dropdown.addOption(language, LANGUAGES[language]);
            }
            dropdown.setValue(plugin.settings.defaultLanguage)
                .onChange((value) => __awaiter(this, void 0, void 0, function* () {
                plugin.settings.defaultLanguage = value;
                yield this.save();
                this.display();
            }));
        });
        new obsidian.Setting(containerEl)
            .setName(t('Definition Provider'))
            .setDesc(t('The API the Plugin will use to search for Definitions.'))
            .addDropdown((dropdown) => {
            for (const api of plugin.manager.definitionProvider) {
                if (api.supportedLanguages.contains(plugin.settings.defaultLanguage)) {
                    dropdown.addOption(api.name, api.name);
                }
            }
            dropdown.setValue(plugin.settings.definitionApiName)
                .onChange((value) => __awaiter(this, void 0, void 0, function* () {
                plugin.settings.definitionApiName = value;
                yield this.save();
            }));
        });
        new obsidian.Setting(containerEl)
            .setName(t('Synonym Provider'))
            .setDesc(t('The API the Plugin will use to search for Synonyms.'))
            .addDropdown((dropdown) => {
            for (const api of plugin.manager.synonymProvider) {
                if (api.supportedLanguages.contains(plugin.settings.defaultLanguage)) {
                    dropdown.addOption(api.name, api.name);
                }
            }
            dropdown.setValue(plugin.settings.synonymApiName)
                .onChange((value) => __awaiter(this, void 0, void 0, function* () {
                plugin.settings.synonymApiName = value;
                yield this.save();
            }));
        });
        new obsidian.Setting(containerEl)
            .setName(t('Synonym Suggestions'))
            .setDesc(t('Show synonyms for highlighted words'))
            .addToggle(toggle => {
            if (plugin.settings.shouldShowSynonymPopover) {
                toggle.setValue(true);
            }
            else {
                toggle.setValue(false);
            }
            toggle.onChange((value) => __awaiter(this, void 0, void 0, function* () {
                plugin.settings.shouldShowSynonymPopover = value;
                yield this.save();
            }));
        });
        const desc = document.createDocumentFragment();
        desc.append(t('Enabling this will allow the Plugin to analyze full sentences to better suggest synonyms based on the context.'), desc.createEl("br"), t('Click '), desc.createEl("a", {
            href: "https://github.com/phibr0/obsidian-dictionary#privacy",
            text: t('here')
        }), t(' for Privacy Concerns.'));
        new obsidian.Setting(containerEl)
            .setName(t('Advanced Synonym Search'))
            .setDesc(desc)
            .addToggle(toggle => {
            toggle.setValue(plugin.settings.advancedSynonymAnalysis);
            toggle.onChange((value) => __awaiter(this, void 0, void 0, function* () {
                plugin.settings.advancedSynonymAnalysis = value;
                yield this.save();
            }));
        });
        const d = document.createDocumentFragment();
        d.append(t('Enable custom Context Menu with options to search for synonyms (only if the auto suggestions are disabled) and to look up a full definition in the Sidebar. Warning: This will override Obsidian\'s default Context Menu.'), d.createEl("br"), 
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        //@ts-ignore
        d.createEl("a", { text: t("Click Here"), href: this.app.plugins.getPlugin("hotkey-helper") ? "obsidian://goto-plugin?id=extended-context-menu" : "https://github.com/phibr0/obsidian-extended-context-menu" }));
        new obsidian.Setting(containerEl)
            .setName(t('Show Options in Context Menu'))
            .setDesc(d)
            .addToggle(toggle => {
            if (plugin.settings.shouldShowCustomContextMenu) {
                toggle.setValue(true);
            }
            else {
                toggle.setValue(false);
            }
            toggle.onChange((value) => __awaiter(this, void 0, void 0, function* () {
                plugin.settings.shouldShowCustomContextMenu = value;
                yield this.save();
            }));
        });
        containerEl.createEl('h3', { text: t("Local-Dictionary-Builder Settings") });
        new obsidian.Setting(containerEl)
            .setName(t('Local Dictionary Folder'))
            .setDesc(t('Specify a Folder, where all new Notes created by the Dictionary are placed. Please note that this Folder needs to already exist.'))
            .addText(text => text
            .setPlaceholder(t('Dictionary'))
            .setValue(plugin.settings.folder)
            .onChange((value) => __awaiter(this, void 0, void 0, function* () {
            plugin.settings.folder = value;
            yield this.save();
        })));
        new obsidian.Setting(containerEl)
            .setName(t('Capitalize File Name'))
            .setDesc(t('If you disable this, the names of newly created files will be all lowercase.'))
            .addToggle(toggle => {
            toggle.setValue(plugin.settings.capitalizedFileName);
            toggle.onChange((value) => __awaiter(this, void 0, void 0, function* () {
                plugin.settings.capitalizedFileName = value;
                yield this.save();
            }));
        });
        new obsidian.Setting(containerEl)
            .setName(t('Filename Prefix and Suffix'))
            .setDesc(t('Here you can add a Prefix and Suffix for your newly created Files.'))
            .setClass("dictionaryprefixsuffix")
            .addText(text => text
            .setPlaceholder(t("Prefix"))
            .setValue(plugin.settings.prefix)
            .onChange((value) => __awaiter(this, void 0, void 0, function* () {
            plugin.settings.prefix = value;
            yield this.save();
        })))
            .addText(text => text
            .setPlaceholder(t("Suffix"))
            .setValue(plugin.settings.suffix)
            .onChange((value) => __awaiter(this, void 0, void 0, function* () {
            plugin.settings.suffix = value;
            yield this.save();
        })));
        const templateDescription = document.createDocumentFragment();
        templateDescription.append(t('Here you can edit the Template for newly created Files.'), templateDescription.createEl("br"), templateDescription.createEl("a", {
            href: "https://github.com/phibr0/obsidian-dictionary#variables",
            text: t('Click for a List of Variables'),
        }));
        new obsidian.Setting(containerEl)
            .setName(t('Template'))
            .setDesc(templateDescription)
            .setClass("dictionarytextarea")
            .addTextArea(text => text
            .setPlaceholder(DEFAULT_SETTINGS.template)
            .setValue(plugin.settings.template)
            .onChange((value) => __awaiter(this, void 0, void 0, function* () {
            plugin.settings.template = value;
            yield this.save();
        })));
        containerEl.createEl('h3', { text: t("Miscellaneous") });
        new obsidian.Setting(containerEl)
            .setName(t('More Information'))
            .setDesc(t('View Information about the API\'s and the Plugin itself.'))
            .setClass("extra")
            .addButton((bt) => {
            bt.setButtonText(t('More Info'));
            bt.onClick((_) => {
                new InfoModal(plugin).open();
            });
        });
        new obsidian.Setting(containerEl)
            .setName(t('Donate'))
            .setDesc(t('If you like this Plugin, consider donating to support continued development:'))
            .setClass("extra")
            .addButton((bt) => {
            bt.buttonEl.outerHTML = `<a href="https://www.buymeacoffee.com/phibr0"><img src="https://img.buymeacoffee.com/button-api/?text=Buy me a coffee&emoji=&slug=phibr0&button_colour=5F7FFF&font_colour=ffffff&font_family=Inter&outline_colour=000000&coffee_colour=FFDD00"></a>`;
        });
    }
    save() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.plugin.saveSettings();
        });
    }
}
class InfoModal extends obsidian.Modal {
    constructor(plugin) {
        super(plugin.app);
        this.plugin = plugin;
    }
    onOpen() {
        this.contentEl.parentElement.style.padding = "10px 12px";
        this._view = new InfoModal$1({
            target: this.contentEl,
            props: {
                synonymAPIs: this.plugin.manager.synonymProvider,
                definitionAPIs: this.plugin.manager.definitionProvider,
                partOfSpeechAPIs: this.plugin.manager.partOfSpeechProvider,
            }
        });
    }
    onClose() {
        this._view.$destroy();
        this.contentEl.empty();
    }
}

/* src/ui/dictionary/phoneticComponent.svelte generated by Svelte v3.38.2 */

function add_css$4() {
	var style = element("style");
	style.id = "svelte-jpkc8o-style";
	style.textContent = ".main.svelte-jpkc8o.svelte-jpkc8o.svelte-jpkc8o{background-color:var(--background-secondary);padding-left:0.6rem;padding-right:0.6rem;padding-top:0.3rem;padding-bottom:0.3rem;margin-bottom:0.3rem;border-radius:0.3rem}audio.svelte-jpkc8o.svelte-jpkc8o.svelte-jpkc8o{margin-top:0.3rem}details[open].svelte-jpkc8o summary.svelte-jpkc8o~.svelte-jpkc8o{animation:svelte-jpkc8o-open 0.2s ease-in-out}@keyframes svelte-jpkc8o-open{0%{opacity:0}100%{opacity:1}}";
	append(document.head, style);
}

// (14:2) {:else}
function create_else_block(ctx) {
	let t_value = /*text*/ ctx[0].replace("/", "").replace("/", "") + "";
	let t;

	return {
		c() {
			t = text(t_value);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*text*/ 1 && t_value !== (t_value = /*text*/ ctx[0].replace("/", "").replace("/", "") + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (6:2) {#if audio}
function create_if_block$3(ctx) {
	let details;
	let summary;
	let t0_value = /*text*/ ctx[0].replace("/", "").replace("/", "") + "";
	let t0;
	let t1;
	let audio_1;
	let source;
	let source_src_value;

	return {
		c() {
			details = element("details");
			summary = element("summary");
			t0 = text(t0_value);
			t1 = space();
			audio_1 = element("audio");
			source = element("source");
			attr(summary, "class", "svelte-jpkc8o");
			if (source.src !== (source_src_value = /*audio*/ ctx[1])) attr(source, "src", source_src_value);
			attr(source, "type", "audio/mpeg");
			audio_1.controls = true;
			attr(audio_1, "class", "svelte-jpkc8o");
			attr(details, "class", "svelte-jpkc8o");
		},
		m(target, anchor) {
			insert(target, details, anchor);
			append(details, summary);
			append(summary, t0);
			append(details, t1);
			append(details, audio_1);
			append(audio_1, source);
		},
		p(ctx, dirty) {
			if (dirty & /*text*/ 1 && t0_value !== (t0_value = /*text*/ ctx[0].replace("/", "").replace("/", "") + "")) set_data(t0, t0_value);

			if (dirty & /*audio*/ 2 && source.src !== (source_src_value = /*audio*/ ctx[1])) {
				attr(source, "src", source_src_value);
			}
		},
		d(detaching) {
			if (detaching) detach(details);
		}
	};
}

function create_fragment$4(ctx) {
	let div;

	function select_block_type(ctx, dirty) {
		if (/*audio*/ ctx[1]) return create_if_block$3;
		return create_else_block;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type(ctx);

	return {
		c() {
			div = element("div");
			if_block.c();
			attr(div, "class", "main svelte-jpkc8o");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			if_block.m(div, null);
		},
		p(ctx, [dirty]) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(div, null);
				}
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div);
			if_block.d();
		}
	};
}

function instance$4($$self, $$props, $$invalidate) {
	let { text } = $$props;
	let { audio } = $$props;

	$$self.$$set = $$props => {
		if ("text" in $$props) $$invalidate(0, text = $$props.text);
		if ("audio" in $$props) $$invalidate(1, audio = $$props.audio);
	};

	return [text, audio];
}

class PhoneticComponent extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-jpkc8o-style")) add_css$4();
		init(this, options, instance$4, create_fragment$4, safe_not_equal, { text: 0, audio: 1 });
	}
}

/* src/ui/dictionary/meaningComponent.svelte generated by Svelte v3.38.2 */

function add_css$3() {
	var style = element("style");
	style.id = "svelte-nmuzfy-style";
	style.textContent = ".main.svelte-nmuzfy.svelte-nmuzfy.svelte-nmuzfy{background-color:var(--background-secondary);padding-left:0.6rem;padding-right:0.6rem;padding-top:0.3rem;padding-bottom:0.3rem;margin-bottom:0.3rem;border-radius:0.3rem}.main.svelte-nmuzfy details.svelte-nmuzfy>summary.svelte-nmuzfy{text-transform:capitalize}.main.svelte-nmuzfy blockquote.svelte-nmuzfy.svelte-nmuzfy{font-style:italic;margin:0 0 1rem;padding-left:1rem;border-left:1px solid var(--background-modifier-border)}.main.svelte-nmuzfy .mark{box-shadow:inset 0 -2px var(--text-faint)}.label.svelte-nmuzfy.svelte-nmuzfy.svelte-nmuzfy{font-size:0.875em;font-weight:bold}details[open].svelte-nmuzfy summary.svelte-nmuzfy~.svelte-nmuzfy{animation:svelte-nmuzfy-open 0.3s ease-in-out}@keyframes svelte-nmuzfy-open{0%{opacity:0}100%{opacity:1}}.synonyms.svelte-nmuzfy.svelte-nmuzfy.svelte-nmuzfy{padding-top:1rem}.synonyms.svelte-nmuzfy>p.svelte-nmuzfy.svelte-nmuzfy,.definition.svelte-nmuzfy>p.svelte-nmuzfy.svelte-nmuzfy{margin-top:0}.definition.svelte-nmuzfy.svelte-nmuzfy.svelte-nmuzfy{padding:1.5rem 0;border-bottom:1px solid var(--background-modifier-border)}.definition.svelte-nmuzfy.svelte-nmuzfy.svelte-nmuzfy:last-child{border-bottom:none}";
	append(document.head, style);
}

function get_each_context$2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[3] = list[i];
	child_ctx[5] = i;
	return child_ctx;
}

function get_each_context_1$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[6] = list[i];
	child_ctx[5] = i;
	return child_ctx;
}

// (14:8) {#if definition.definition}
function create_if_block_3(ctx) {
	let div;
	let t1;
	let p;
	let t2_value = /*definition*/ ctx[3].definition + "";
	let t2;

	return {
		c() {
			div = element("div");
			div.textContent = `${t("Definition:")}`;
			t1 = space();
			p = element("p");
			t2 = text(t2_value);
			attr(div, "class", "label svelte-nmuzfy");
			attr(p, "class", "svelte-nmuzfy");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			insert(target, t1, anchor);
			insert(target, p, anchor);
			append(p, t2);
		},
		p(ctx, dirty) {
			if (dirty & /*definitions*/ 2 && t2_value !== (t2_value = /*definition*/ ctx[3].definition + "")) set_data(t2, t2_value);
		},
		d(detaching) {
			if (detaching) detach(div);
			if (detaching) detach(t1);
			if (detaching) detach(p);
		}
	};
}

// (18:8) {#if definition.example}
function create_if_block_2(ctx) {
	let blockquote;
	let raw_value = /*definition*/ ctx[3].example.replace(new RegExp(`(${/*word*/ ctx[0]})`, "gi"), "<i class=\"mark\">$1</i>") + "";

	return {
		c() {
			blockquote = element("blockquote");
			attr(blockquote, "class", "svelte-nmuzfy");
		},
		m(target, anchor) {
			insert(target, blockquote, anchor);
			blockquote.innerHTML = raw_value;
		},
		p(ctx, dirty) {
			if (dirty & /*definitions, word*/ 3 && raw_value !== (raw_value = /*definition*/ ctx[3].example.replace(new RegExp(`(${/*word*/ ctx[0]})`, "gi"), "<i class=\"mark\">$1</i>") + "")) blockquote.innerHTML = raw_value;		},
		d(detaching) {
			if (detaching) detach(blockquote);
		}
	};
}

// (28:8) {#if definition.synonyms && definition.synonyms[i]}
function create_if_block$2(ctx) {
	let div1;
	let div0;
	let t1;
	let p;
	let each_value_1 = /*definition*/ ctx[3].synonyms;
	let each_blocks = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks[i] = create_each_block_1$1(get_each_context_1$1(ctx, each_value_1, i));
	}

	return {
		c() {
			div1 = element("div");
			div0 = element("div");
			div0.textContent = `${t("Synonyms:")}`;
			t1 = space();
			p = element("p");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr(div0, "class", "label svelte-nmuzfy");
			attr(p, "class", "svelte-nmuzfy");
			attr(div1, "class", "synonyms svelte-nmuzfy");
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			append(div1, div0);
			append(div1, t1);
			append(div1, p);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(p, null);
			}
		},
		p(ctx, dirty) {
			if (dirty & /*definitions*/ 2) {
				each_value_1 = /*definition*/ ctx[3].synonyms;
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1$1(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_1$1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(p, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_1.length;
			}
		},
		d(detaching) {
			if (detaching) detach(div1);
			destroy_each(each_blocks, detaching);
		}
	};
}

// (33:25) {#if i < definition.synonyms.length - 1}
function create_if_block_1$2(ctx) {
	let t_1_value = ", " + "";
	let t_1;

	return {
		c() {
			t_1 = text(t_1_value);
		},
		m(target, anchor) {
			insert(target, t_1, anchor);
		},
		d(detaching) {
			if (detaching) detach(t_1);
		}
	};
}

// (32:14) {#each definition.synonyms as synonym, i}
function create_each_block_1$1(ctx) {
	let t_1_value = /*synonym*/ ctx[6] + "";
	let t_1;
	let if_block_anchor;
	let if_block = /*i*/ ctx[5] < /*definition*/ ctx[3].synonyms.length - 1 && create_if_block_1$2();

	return {
		c() {
			t_1 = text(t_1_value);
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			insert(target, t_1, anchor);
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*definitions*/ 2 && t_1_value !== (t_1_value = /*synonym*/ ctx[6] + "")) set_data(t_1, t_1_value);

			if (/*i*/ ctx[5] < /*definition*/ ctx[3].synonyms.length - 1) {
				if (if_block) ; else {
					if_block = create_if_block_1$2();
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d(detaching) {
			if (detaching) detach(t_1);
			if (if_block) if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

// (12:4) {#each definitions as definition, i}
function create_each_block$2(ctx) {
	let div;
	let t0;
	let t1;
	let t2;
	let if_block0 = /*definition*/ ctx[3].definition && create_if_block_3(ctx);
	let if_block1 = /*definition*/ ctx[3].example && create_if_block_2(ctx);
	let if_block2 = /*definition*/ ctx[3].synonyms && /*definition*/ ctx[3].synonyms[/*i*/ ctx[5]] && create_if_block$2(ctx);

	return {
		c() {
			div = element("div");
			if (if_block0) if_block0.c();
			t0 = space();
			if (if_block1) if_block1.c();
			t1 = space();
			if (if_block2) if_block2.c();
			t2 = space();
			attr(div, "class", "definition svelte-nmuzfy");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			if (if_block0) if_block0.m(div, null);
			append(div, t0);
			if (if_block1) if_block1.m(div, null);
			append(div, t1);
			if (if_block2) if_block2.m(div, null);
			append(div, t2);
		},
		p(ctx, dirty) {
			if (/*definition*/ ctx[3].definition) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_3(ctx);
					if_block0.c();
					if_block0.m(div, t0);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*definition*/ ctx[3].example) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_2(ctx);
					if_block1.c();
					if_block1.m(div, t1);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (/*definition*/ ctx[3].synonyms && /*definition*/ ctx[3].synonyms[/*i*/ ctx[5]]) {
				if (if_block2) {
					if_block2.p(ctx, dirty);
				} else {
					if_block2 = create_if_block$2(ctx);
					if_block2.c();
					if_block2.m(div, t2);
				}
			} else if (if_block2) {
				if_block2.d(1);
				if_block2 = null;
			}
		},
		d(detaching) {
			if (detaching) detach(div);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (if_block2) if_block2.d();
		}
	};
}

function create_fragment$3(ctx) {
	let div;
	let details;
	let summary;
	let t0;
	let t1;
	let each_value = /*definitions*/ ctx[1];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
	}

	return {
		c() {
			div = element("div");
			details = element("details");
			summary = element("summary");
			t0 = text(/*partOfSpeech*/ ctx[2]);
			t1 = space();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr(summary, "class", "svelte-nmuzfy");
			attr(details, "class", "svelte-nmuzfy");
			attr(div, "class", "main svelte-nmuzfy");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, details);
			append(details, summary);
			append(summary, t0);
			append(details, t1);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(details, null);
			}
		},
		p(ctx, [dirty]) {
			if (dirty & /*partOfSpeech*/ 4) set_data(t0, /*partOfSpeech*/ ctx[2]);

			if (dirty & /*definitions, t, RegExp, word*/ 3) {
				each_value = /*definitions*/ ctx[1];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$2(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$2(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(details, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div);
			destroy_each(each_blocks, detaching);
		}
	};
}

function instance$3($$self, $$props, $$invalidate) {
	
	let { word } = $$props;
	let { definitions } = $$props;
	let { partOfSpeech } = $$props;

	$$self.$$set = $$props => {
		if ("word" in $$props) $$invalidate(0, word = $$props.word);
		if ("definitions" in $$props) $$invalidate(1, definitions = $$props.definitions);
		if ("partOfSpeech" in $$props) $$invalidate(2, partOfSpeech = $$props.partOfSpeech);
	};

	return [word, definitions, partOfSpeech];
}

class MeaningComponent extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-nmuzfy-style")) add_css$3();
		init(this, options, instance$3, create_fragment$3, safe_not_equal, { word: 0, definitions: 1, partOfSpeech: 2 });
	}
}

/* src/ui/dictionary/errorComponent.svelte generated by Svelte v3.38.2 */

function add_css$2() {
	var style = element("style");
	style.id = "svelte-1lk7r5d-style";
	style.textContent = ".error.svelte-1lk7r5d{text-align:center;width:100%;color:var(--text-muted)}.errorDescription.svelte-1lk7r5d{text-align:center;width:100%;font-size:0.9em;color:var(--text-faint)}";
	append(document.head, style);
}

function create_fragment$2(ctx) {
	let div;
	let p0;
	let t1;
	let p1;
	let t3;
	let details;
	let t4_value = (/*error*/ ctx[0] ?? "") + "";
	let t4;

	return {
		c() {
			div = element("div");
			p0 = element("p");
			p0.textContent = "Something went wrong..";
			t1 = space();
			p1 = element("p");
			p1.textContent = `${t("I can't find the word you are looking for or the server can't be reached. You can try again in a few minutes.")}`;
			t3 = space();
			details = element("details");
			t4 = text(t4_value);
			attr(p0, "class", "error svelte-1lk7r5d");
			attr(p1, "class", "errorDescription svelte-1lk7r5d");
			set_style(details, "display", "none");
			attr(div, "class", "main");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, p0);
			append(div, t1);
			append(div, p1);
			append(div, t3);
			append(div, details);
			append(details, t4);
		},
		p(ctx, [dirty]) {
			if (dirty & /*error*/ 1 && t4_value !== (t4_value = (/*error*/ ctx[0] ?? "") + "")) set_data(t4, t4_value);
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

function instance$2($$self, $$props, $$invalidate) {
	let { error } = $$props;

	$$self.$$set = $$props => {
		if ("error" in $$props) $$invalidate(0, error = $$props.error);
	};

	return [error];
}

class ErrorComponent extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-1lk7r5d-style")) add_css$2();
		init(this, options, instance$2, create_fragment$2, safe_not_equal, { error: 0 });
	}
}

/* src/ui/dictionary/dictionaryView.svelte generated by Svelte v3.38.2 */

function add_css$1() {
	var style = element("style");
	style.id = "svelte-19jc5lb-style";
	style.textContent = ".results.svelte-19jc5lb.svelte-19jc5lb{display:flex;flex-wrap:wrap}.nn.svelte-19jc5lb.svelte-19jc5lb{color:var(--text-faint);transition:0.2s;width:100%;display:inline-block;text-align:center;margin-top:1.5rem;font-size:1em}.nn.svelte-19jc5lb.svelte-19jc5lb:hover{color:var(--text)}.container.svelte-19jc5lb.svelte-19jc5lb{max-width:30vw;width:100%;margin:auto;background-color:var(--background-primary-alt);padding-left:0.5rem;padding-right:0.5rem;padding-top:0.3rem;padding-bottom:0.3rem;margin-top:0.5rem;border-radius:0.3rem}.container.svelte-19jc5lb>h3.svelte-19jc5lb{margin-top:0.3rem;margin-bottom:0.3rem;font-weight:normal}.searchbox.svelte-19jc5lb.svelte-19jc5lb{margin-top:0.1rem;display:flex}.searchbox.svelte-19jc5lb>input.svelte-19jc5lb{width:100%;margin-right:0.8rem;margin-left:0.8rem}.dictionary-button.svelte-19jc5lb.svelte-19jc5lb{margin-right:0px}.searchIcon.svelte-19jc5lb.svelte-19jc5lb{box-sizing:border-box;position:relative;display:block;transform:scale(var(--ggs, 1));width:16px;height:16px;border:2px solid;border-radius:100%;margin-left:-4px;margin-top:-4px}.searchIcon.svelte-19jc5lb.svelte-19jc5lb::after{content:\"\";display:block;box-sizing:border-box;position:absolute;border-radius:3px;width:2px;height:8px;background:currentColor;transform:rotate(-45deg);top:10px;left:12px}.languageIcon.svelte-19jc5lb.svelte-19jc5lb,.languageIcon.svelte-19jc5lb.svelte-19jc5lb::after,.languageIcon.svelte-19jc5lb.svelte-19jc5lb::before{display:block;box-sizing:border-box;height:18px;border:2px solid}.languageIcon.svelte-19jc5lb.svelte-19jc5lb{position:relative;transform:scale(var(--ggs, 1));width:18px;border-radius:22px}.languageIcon.svelte-19jc5lb.svelte-19jc5lb::after,.languageIcon.svelte-19jc5lb.svelte-19jc5lb::before{content:\"\";position:absolute;width:8px;border-radius:100%;top:-2px;left:3px}.languageIcon.svelte-19jc5lb.svelte-19jc5lb::after{width:24px;height:20px;border:2px solid transparent;border-bottom:2px solid;top:-11px;left:-5px}.center.svelte-19jc5lb.svelte-19jc5lb{margin:auto;width:100%;margin-top:2rem}@keyframes svelte-19jc5lb-spinner{0%{transform:translate3d(-50%, -50%, 0) rotate(0deg)}100%{transform:translate3d(-50%, -50%, 0) rotate(360deg)}}.spinner.svelte-19jc5lb.svelte-19jc5lb{height:3rem;opacity:1;position:relative;transition:opacity linear 0.1s}.spinner.svelte-19jc5lb.svelte-19jc5lb::before{animation:2s linear infinite svelte-19jc5lb-spinner;border:solid 3px var(--background-modifier-border);border-bottom-color:var(--interactive-accent);border-radius:50%;content:\"\";height:40px;left:50%;opacity:inherit;position:absolute;top:50%;transform:translate3d(-50%, -50%, 0);transform-origin:center;width:40px;will-change:transform}";
	append(document.head, style);
}

function get_each_context$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[9] = list[i].definitions;
	child_ctx[10] = list[i].partOfSpeech;
	return child_ctx;
}

function get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[13] = list[i].text;
	child_ctx[14] = list[i].audio;
	return child_ctx;
}

// (42:2) {#if query.trim() != "" && promise}
function create_if_block$1(ctx) {
	let await_block_anchor;
	let promise_1;
	let current;

	let info = {
		ctx,
		current: null,
		token: null,
		hasCatch: true,
		pending: create_pending_block,
		then: create_then_block,
		catch: create_catch_block,
		value: 8,
		error: 17,
		blocks: [,,,]
	};

	handle_promise(promise_1 = /*promise*/ ctx[2], info);

	return {
		c() {
			await_block_anchor = empty();
			info.block.c();
		},
		m(target, anchor) {
			insert(target, await_block_anchor, anchor);
			info.block.m(target, info.anchor = anchor);
			info.mount = () => await_block_anchor.parentNode;
			info.anchor = await_block_anchor;
			current = true;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			info.ctx = ctx;

			if (dirty & /*promise*/ 4 && promise_1 !== (promise_1 = /*promise*/ ctx[2]) && handle_promise(promise_1, info)) ; else {
				update_await_block_branch(info, ctx, dirty);
			}
		},
		i(local) {
			if (current) return;
			transition_in(info.block);
			current = true;
		},
		o(local) {
			for (let i = 0; i < 3; i += 1) {
				const block = info.blocks[i];
				transition_out(block);
			}

			current = false;
		},
		d(detaching) {
			if (detaching) detach(await_block_anchor);
			info.block.d(detaching);
			info.token = null;
			info = null;
		}
	};
}

// (69:4) {:catch error}
function create_catch_block(ctx) {
	let errorcomponent;
	let current;
	errorcomponent = new ErrorComponent({ props: { error: /*error*/ ctx[17] } });

	return {
		c() {
			create_component(errorcomponent.$$.fragment);
		},
		m(target, anchor) {
			mount_component(errorcomponent, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const errorcomponent_changes = {};
			if (dirty & /*promise*/ 4) errorcomponent_changes.error = /*error*/ ctx[17];
			errorcomponent.$set(errorcomponent_changes);
		},
		i(local) {
			if (current) return;
			transition_in(errorcomponent.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(errorcomponent.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(errorcomponent, detaching);
		}
	};
}

// (47:4) {:then data}
function create_then_block(ctx) {
	let div1;
	let show_if = /*data*/ ctx[8].phonetics.first().text;
	let t0;
	let div0;
	let h3;
	let t2;
	let t3;
	let span;
	let current;
	let mounted;
	let dispose;
	let if_block = show_if && create_if_block_1$1(ctx);
	let each_value = /*data*/ ctx[8].meanings;
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	function click_handler() {
		return /*click_handler*/ ctx[7](/*data*/ ctx[8]);
	}

	return {
		c() {
			div1 = element("div");
			if (if_block) if_block.c();
			t0 = space();
			div0 = element("div");
			h3 = element("h3");
			h3.textContent = `${t("Meanings")}`;
			t2 = space();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t3 = space();
			span = element("span");
			span.textContent = `${t("New Note")}`;
			attr(h3, "class", "svelte-19jc5lb");
			attr(div0, "class", "container svelte-19jc5lb");
			attr(div1, "class", "results svelte-19jc5lb");
			attr(span, "class", "nn svelte-19jc5lb");
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			if (if_block) if_block.m(div1, null);
			append(div1, t0);
			append(div1, div0);
			append(div0, h3);
			append(div0, t2);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div0, null);
			}

			insert(target, t3, anchor);
			insert(target, span, anchor);
			current = true;

			if (!mounted) {
				dispose = listen(span, "click", click_handler);
				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*promise*/ 4) show_if = /*data*/ ctx[8].phonetics.first().text;

			if (show_if) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*promise*/ 4) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_1$1(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(div1, t0);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			if (dirty & /*promise*/ 4) {
				each_value = /*data*/ ctx[8].meanings;
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$1(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block$1(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(div0, null);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			transition_out(if_block);
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			if (detaching) detach(div1);
			if (if_block) if_block.d();
			destroy_each(each_blocks, detaching);
			if (detaching) detach(t3);
			if (detaching) detach(span);
			mounted = false;
			dispose();
		}
	};
}

// (49:8) {#if data.phonetics.first().text}
function create_if_block_1$1(ctx) {
	let div;
	let h3;
	let t1;
	let current;
	let each_value_1 = /*data*/ ctx[8].phonetics;
	let each_blocks = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	return {
		c() {
			div = element("div");
			h3 = element("h3");
			h3.textContent = `${t("Pronunciation")}`;
			t1 = space();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr(h3, "class", "svelte-19jc5lb");
			attr(div, "class", "container svelte-19jc5lb");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, h3);
			append(div, t1);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (dirty & /*promise*/ 4) {
				each_value_1 = /*data*/ ctx[8].phonetics;
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block_1(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(div, null);
					}
				}

				group_outros();

				for (i = each_value_1.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value_1.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_each(each_blocks, detaching);
		}
	};
}

// (52:12) {#each data.phonetics as { text, audio }}
function create_each_block_1(ctx) {
	let phoneticcomponent;
	let current;

	phoneticcomponent = new PhoneticComponent({
			props: {
				audio: /*audio*/ ctx[14],
				text: /*text*/ ctx[13]
			}
		});

	return {
		c() {
			create_component(phoneticcomponent.$$.fragment);
		},
		m(target, anchor) {
			mount_component(phoneticcomponent, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const phoneticcomponent_changes = {};
			if (dirty & /*promise*/ 4) phoneticcomponent_changes.audio = /*audio*/ ctx[14];
			if (dirty & /*promise*/ 4) phoneticcomponent_changes.text = /*text*/ ctx[13];
			phoneticcomponent.$set(phoneticcomponent_changes);
		},
		i(local) {
			if (current) return;
			transition_in(phoneticcomponent.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(phoneticcomponent.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(phoneticcomponent, detaching);
		}
	};
}

// (59:10) {#each data.meanings as { definitions, partOfSpeech }}
function create_each_block$1(ctx) {
	let meaningcomponent;
	let current;

	meaningcomponent = new MeaningComponent({
			props: {
				word: /*data*/ ctx[8].word,
				partOfSpeech: /*partOfSpeech*/ ctx[10],
				definitions: /*definitions*/ ctx[9]
			}
		});

	return {
		c() {
			create_component(meaningcomponent.$$.fragment);
		},
		m(target, anchor) {
			mount_component(meaningcomponent, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const meaningcomponent_changes = {};
			if (dirty & /*promise*/ 4) meaningcomponent_changes.word = /*data*/ ctx[8].word;
			if (dirty & /*promise*/ 4) meaningcomponent_changes.partOfSpeech = /*partOfSpeech*/ ctx[10];
			if (dirty & /*promise*/ 4) meaningcomponent_changes.definitions = /*definitions*/ ctx[9];
			meaningcomponent.$set(meaningcomponent_changes);
		},
		i(local) {
			if (current) return;
			transition_in(meaningcomponent.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(meaningcomponent.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(meaningcomponent, detaching);
		}
	};
}

// (43:20)        <div class="center">         <div class="spinner" />       </div>     {:then data}
function create_pending_block(ctx) {
	let div1;

	return {
		c() {
			div1 = element("div");
			div1.innerHTML = `<div class="spinner svelte-19jc5lb"></div>`;
			attr(div1, "class", "center svelte-19jc5lb");
		},
		m(target, anchor) {
			insert(target, div1, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div1);
		}
	};
}

function create_fragment$1(ctx) {
	let div1;
	let div0;
	let button0;
	let t0;
	let input;
	let t1;
	let button1;
	let t2;
	let show_if = /*query*/ ctx[0].trim() != "" && /*promise*/ ctx[2];
	let current;
	let mounted;
	let dispose;
	let if_block = show_if && create_if_block$1(ctx);

	return {
		c() {
			div1 = element("div");
			div0 = element("div");
			button0 = element("button");
			button0.innerHTML = `<i class="languageIcon svelte-19jc5lb" alt="Language"></i>`;
			t0 = space();
			input = element("input");
			t1 = space();
			button1 = element("button");
			button1.innerHTML = `<i class="searchIcon svelte-19jc5lb" alt="Search"></i>`;
			t2 = space();
			if (if_block) if_block.c();
			attr(button0, "class", "dictionary-button svelte-19jc5lb");
			attr(input, "type", "text");
			attr(input, "spellcheck", "true");
			attr(input, "placeholder", t("Enter a word"));
			attr(input, "class", "svelte-19jc5lb");
			attr(button1, "class", "dictionary-button svelte-19jc5lb");
			attr(div0, "class", "searchbox svelte-19jc5lb");
			attr(div1, "class", "main");
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			append(div1, div0);
			append(div0, button0);
			append(div0, t0);
			append(div0, input);
			set_input_value(input, /*query*/ ctx[0]);
			append(div0, t1);
			append(div0, button1);
			append(div1, t2);
			if (if_block) if_block.m(div1, null);
			current = true;

			if (!mounted) {
				dispose = [
					listen(button0, "click", languageModal),
					listen(input, "input", /*input_input_handler*/ ctx[6]),
					listen(input, "keydown", /*handleKeyDown*/ ctx[4]),
					listen(button1, "click", /*search*/ ctx[3])
				];

				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (dirty & /*query*/ 1 && input.value !== /*query*/ ctx[0]) {
				set_input_value(input, /*query*/ ctx[0]);
			}

			if (dirty & /*query, promise*/ 5) show_if = /*query*/ ctx[0].trim() != "" && /*promise*/ ctx[2];

			if (show_if) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*query, promise*/ 5) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$1(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(div1, null);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div1);
			if (if_block) if_block.d();
			mounted = false;
			run_all(dispose);
		}
	};
}

function languageModal() {
	dispatchEvent(new Event("dictionary-open-language-switcher"));
}

function instance$1($$self, $$props, $$invalidate) {
	
	
	
	let { manager } = $$props;
	let { localDictionary } = $$props;
	let { query = "" } = $$props;
	let promise;

	function search() {
		if (query.trim() !== "") {
			$$invalidate(2, promise = manager.requestDefinitions(query));
		}
	}

	addEventListener("obsidian-dictionary-plugin-search", () => {
		search();
	});

	function handleKeyDown(e) {
		if (e.key === "Enter") {
			search();
		}
	}

	function input_input_handler() {
		query = this.value;
		$$invalidate(0, query);
	}

	const click_handler = async data => await localDictionary.newNote(data);

	$$self.$$set = $$props => {
		if ("manager" in $$props) $$invalidate(5, manager = $$props.manager);
		if ("localDictionary" in $$props) $$invalidate(1, localDictionary = $$props.localDictionary);
		if ("query" in $$props) $$invalidate(0, query = $$props.query);
	};

	return [
		query,
		localDictionary,
		promise,
		search,
		handleKeyDown,
		manager,
		input_input_handler,
		click_handler
	];
}

class DictionaryView$1 extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-19jc5lb-style")) add_css$1();
		init(this, options, instance$1, create_fragment$1, safe_not_equal, { manager: 5, localDictionary: 1, query: 0 });
	}
}

class SynonymProviderChooser extends obsidian.FuzzySuggestModal {
    constructor(app, plugin) {
        super(app);
        this.available = [];
        this.plugin = plugin;
        this.plugin.manager.synonymProvider.forEach((api) => {
            if (api.supportedLanguages.contains(this.plugin.settings.defaultLanguage)) {
                this.available.push(api.name);
            }
        });
        this.setPlaceholder(t("Choose a Synonym Provider Service"));
    }
    onOpen() {
        var _a;
        if (this.available.length <= 1) {
            this.onChooseItem((_a = this.available.first()) !== null && _a !== void 0 ? _a : "");
        }
    }
    getItems() {
        return this.available;
    }
    getItemText(item) {
        return item;
    }
    onChooseItem(item) {
        return __awaiter(this, void 0, void 0, function* () {
            this.plugin.settings.synonymApiName = item;
            yield this.plugin.saveSettings();
            this.close();
        });
    }
}

class DefinitionProviderChooser extends obsidian.FuzzySuggestModal {
    constructor(app, plugin) {
        super(app);
        this.available = [];
        this.plugin = plugin;
        this.plugin.manager.definitionProvider.forEach((api) => {
            if (api.supportedLanguages.contains(this.plugin.settings.defaultLanguage)) {
                this.available.push(api.name);
            }
        });
        this.setPlaceholder(t("Choose a Definition Provider Service"));
    }
    onOpen() {
        var _a;
        if (this.available.length <= 1) {
            this.onChooseItem((_a = this.available.first()) !== null && _a !== void 0 ? _a : "");
        }
    }
    getItems() {
        return this.available;
    }
    getItemText(item) {
        return item;
    }
    onChooseItem(item) {
        return __awaiter(this, void 0, void 0, function* () {
            this.plugin.settings.definitionApiName = item;
            yield this.plugin.saveSettings();
            this.close();
            new SynonymProviderChooser(this.app, this.plugin).open();
        });
    }
}

class LanguageChooser extends obsidian.FuzzySuggestModal {
    constructor(app, plugin) {
        super(app);
        this.plugin = plugin;
        this.setPlaceholder(t("Choose a Language"));
    }
    getItems() {
        const items = [];
        for (const lang in LANGUAGES) {
            items.push(lang);
        }
        return items;
    }
    getItemText(item) {
        if (item == this.plugin.settings.defaultLanguage) {
            return LANGUAGES[item] + ' 🗸';
        }
        else {
            return LANGUAGES[item];
        }
    }
    onChooseItem(item) {
        return __awaiter(this, void 0, void 0, function* () {
            this.plugin.settings.defaultLanguage = item;
            yield this.plugin.saveSettings();
            this.close();
            new DefinitionProviderChooser(this.app, this.plugin).open();
        });
    }
}

class DictionaryView extends obsidian.ItemView {
    constructor(leaf, plugin) {
        super(leaf);
        this.plugin = plugin;
    }
    query(query) {
        this._view.$set({
            query: query
        });
        dispatchEvent(new Event("obsidian-dictionary-plugin-search"));
    }
    getViewType() {
        return VIEW_TYPE;
    }
    getDisplayText() {
        return VIEW_DISPLAY_TEXT;
    }
    getIcon() {
        return VIEW_ICON;
    }
    onClose() {
        return __awaiter(this, void 0, void 0, function* () {
            this._view.$destroy();
        });
    }
    onOpen() {
        return __awaiter(this, void 0, void 0, function* () {
            this._view = new DictionaryView$1({
                target: this.contentEl,
                props: {
                    manager: this.plugin.manager,
                    localDictionary: this.plugin.localDictionary,
                }
            });
            addEventListener('dictionary-open-language-switcher', () => {
                new LanguageChooser(this.app, this.plugin).open();
            });
        });
    }
}

var PartOfSpeech;
(function (PartOfSpeech) {
    PartOfSpeech[PartOfSpeech["Noun"] = 0] = "Noun";
    PartOfSpeech[PartOfSpeech["Verb"] = 1] = "Verb";
    PartOfSpeech[PartOfSpeech["Adjective"] = 2] = "Adjective";
    PartOfSpeech[PartOfSpeech["Adverb"] = 3] = "Adverb";
})(PartOfSpeech || (PartOfSpeech = {}));

class Base {
    constructor() {
        this.API_END_POINT = "https://api.dictionaryapi.dev/api/v2/entries/";
        this.name = "Free Dictionary API";
        this.url = "https://dictionaryapi.dev/";
    }
    /**
     * @param query - The term you want to look up
     * @returns Returns the URL in REST schema
     */
    constructRequest(query, lang) {
        return this.API_END_POINT + lang + '/' + query;
        //SCHEMA: https://api.dictionaryapi.dev/api/v2/entries/<language_code>/<word>
    }
}
class FreeDictionaryDefinitionProvider extends Base {
    constructor() {
        super(...arguments);
        this.supportedLanguages = [
            "en_US",
            "hi",
            "es",
            "fr",
            "ja",
            "ru",
            "en_GB",
            "de",
            "it",
            "ko",
            "pt-BR",
            "ar",
            "tr",
        ];
    }
    /**
     * Sends a request with the passed query to the End Point and returns the Result
     *
     * @param query - The term you want to look up
     * @param lang - The language to use
     * @param _ - For now unused parameter, debouncing mechanism planned
     * @returns The API Response of the API as Promise<DictionaryWord>
     */
    requestDefinitions(query, lang, _ = true) {
        return __awaiter(this, void 0, void 0, function* () {
            let result;
            try {
                result = yield fetch(this.constructRequest(query, lang));
            }
            catch (error) {
                return Promise.reject(error);
            }
            if (result.status != 200) {
                return Promise.reject("Couldn't find word");
            }
            return (yield result.json()).first();
        });
    }
}
class FreeDictionarySynonymProvider extends Base {
    constructor() {
        super(...arguments);
        this.supportedLanguages = [
            "en_US",
        ];
    }
    /**
     * @param meaning - The Meaning to compare the POS to
     * @param pos - The part of speech of the target word
     * @returns True if the meaning is the same part of speech as pos
     */
    getDoesPosMatch(meaning, pos) {
        switch (pos) {
            case PartOfSpeech.Noun:
                return meaning.partOfSpeech.toLowerCase().contains('noun');
            case PartOfSpeech.Verb:
                return meaning.partOfSpeech.toLowerCase().contains('verb');
            case PartOfSpeech.Adjective:
                return meaning.partOfSpeech.toLowerCase().contains('adjective');
            case PartOfSpeech.Adverb:
                return meaning.partOfSpeech.toLowerCase().contains('adverb');
        }
        return false;
    }
    /**
     *
     * @param query - The word to look up synonyms for
     * @param lang - The host language
     * @param pos - The part of speech of the target word
     * @returns A list of Synonyms
     */
    requestSynonyms(query, lang, pos) {
        return __awaiter(this, void 0, void 0, function* () {
            let result;
            try {
                result = yield fetch(this.constructRequest(query, lang));
            }
            catch (error) {
                return Promise.reject(error);
            }
            if (result.status != 200) {
                return Promise.reject("Couldn't find Word");
            }
            const meanings = (yield result.json()).first().meanings;
            const synonyms = [];
            // The default POS provider seems pretty wonky at the moment,
            // so let's include non-matches in the results as well
            const nonPOSMatch = [];
            meanings.forEach(meaning => {
                if (Number.isNumber(pos) && !this.getDoesPosMatch(meaning, pos)) {
                    meaning.definitions.forEach(def => {
                        if (def.synonyms) {
                            def.synonyms.forEach(synonym => {
                                nonPOSMatch.push({
                                    word: synonym,
                                });
                            });
                        }
                    });
                    return;
                }
                meaning.definitions.forEach(def => {
                    if (def.synonyms) {
                        def.synonyms.forEach(synonym => {
                            synonyms.push({
                                word: synonym,
                            });
                        });
                    }
                });
            });
            return synonyms.concat(nonPOSMatch);
        });
    }
}

class OpenThesaurusSynonymAPI {
    constructor() {
        this.API_END_POINT = "https://www.openthesaurus.de/synonyme/search?q=";
        this.name = "OpenThesaurus";
        this.url = "https://www.openthesaurus.de/";
        this.supportedLanguages = ["de"];
    }
    /**
     * @param query - The term you want to look up
     * @returns Returns the URL in REST schema
     */
    constructRequest(query) {
        return this.API_END_POINT + query + "&format=application/json";
        //SCHEMA: https://www.openthesaurus.de/synonyme/search?q=<QUERY>&format=application/json
    }
    requestSynonyms(query) {
        return __awaiter(this, void 0, void 0, function* () {
            let result;
            try {
                result = yield fetch(this.constructRequest(query));
            }
            catch (error) {
                return Promise.reject(error);
            }
            if (result.status != 200) {
                return Promise.reject();
            }
            const response = yield result.json();
            if (response.synsets.length <= 0) {
                return Promise.reject("No Synonym found");
            }
            const synonymList = response.synsets[0].terms;
            const synonyms = [];
            synonymList.forEach((synonym) => {
                const word = synonym["term"];
                if (query != word) {
                    synonyms.push({ word: word });
                }
            });
            return synonyms;
        });
    }
}

const langMap = {
    ar: "ar",
    de: "de",
    en_US: "en",
    en_GB: "en",
    es: "es",
    fr: "fr",
    ru: "ru",
    it: "it",
    ko: "ko",
    pt: "pt",
    "pt-BR": "pt",
    hi: "hi",
};
/**
 * Systran is used to determine the part of speech of a particular word
 * More languages are supported than listed, but I'm unable to retrieve the entire
 * list at the moment
 */
class SystranPOSProvider {
    constructor() {
        this.API_END_POINT = "https://systran-systran-platform-for-language-processing-v1.p.rapidapi.com/nlp/morphology/extract/pos";
        // This is a free endpoint but still requires a key.
        // The key is encoded to thwart bots, not humans.
        this.key = "NWUxYWZmNGE4ZG1zaDI5ZTZlZmJkMGE2NmUwZXAxYzliNTVqc24zMWI3ODRlMTVhMTc";
        this.name = "Systran API";
        this.url = "https://systran-systran-platform-for-language-processing-v1.p.rapidapi.com/";
        this.supportedLanguages = [
            "ar",
            "de",
            "en_US",
            "en_GB",
            "es",
            "fr",
            "ru",
            "it",
            "ko",
            "pt",
            "pt-BR",
            "hi",
        ];
    }
    /**
     * @param lang - The language defined in settings
     * @returns A language code systran supports
     */
    mapLanguage(lang) {
        return langMap[lang];
    }
    /**
     * @param word - Target word
     * @param leftContext - The sentence content before the word
     * @param rightContext - The sentence content after the word
     * @param lang - The host language
     * @returns - The PartOfSpeech of the word, or null
     */
    requestPartOfSpeech(word, leftContext, rightContext, lang) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let result;
            try {
                result = yield fetch(this.constructRequest(leftContext + word + rightContext, lang), {
                    method: "GET",
                    headers: {
                        "x-rapidapi-key": atob(this.key),
                        "x-rapidapi-host": "systran-systran-platform-for-language-processing-v1.p.rapidapi.com",
                    },
                });
            }
            catch (error) {
                return Promise.reject(error);
            }
            const words = (yield result.json());
            let match = (_a = words.partsOfSpeech) === null || _a === void 0 ? void 0 : _a.find((pos) => pos.start === leftContext.length);
            if (!match && words.partsOfSpeech) {
                match = words.partsOfSpeech.find(pos => {
                    return pos.text.contains(word);
                });
            }
            if (match) {
                const posStr = match.pos.split("/")[1];
                if (posStr.startsWith("noun"))
                    return PartOfSpeech.Noun;
                if (posStr.startsWith("verb"))
                    return PartOfSpeech.Verb;
                if (posStr.startsWith("adj"))
                    return PartOfSpeech.Adjective;
                if (posStr.startsWith("adv"))
                    return PartOfSpeech.Adverb;
            }
            return null;
        });
    }
    constructRequest(input, lang) {
        return (this.API_END_POINT +
            `?input=${encodeURIComponent(input)}&lang=${this.mapLanguage(lang)}`);
    }
}

class SynonymoSynonymAPI {
    constructor() {
        //Yes this doesnt use https
        //We need a Proxy to add cors headers
        this.API_END_POINT = "https://api.allorigins.win/get?url=" + encodeURIComponent('http://www.synonymo.fr/synonyme/');
        this.name = "Synonymo";
        this.url = "http://www.synonymo.fr/";
        this.supportedLanguages = ["fr"];
    }
    /**
     * @param query - The term you want to look up
     * @returns Returns the URL in REST schema
     */
    constructRequest(query) {
        return this.API_END_POINT + query;
        //SCHEMA: http://www.synonymo.fr/synonyme/<QUERY>
    }
    requestSynonyms(query) {
        return __awaiter(this, void 0, void 0, function* () {
            const synonyms = [];
            let result;
            try {
                result = yield fetch(this.constructRequest(query));
            }
            catch (error) {
                return Promise.reject(error);
            }
            if (result.status != 200) {
                return Promise.reject();
            }
            const parser = new DOMParser();
            const doc = parser.parseFromString(yield result.text(), 'text/html');
            const x = doc.body.getElementsByClassName('\\"word\\"');
            console.log(doc);
            for (let i = 0; i < x.length; i++) {
                synonyms.push({ word: x.item(i).textContent });
            }
            return synonyms;
        });
    }
}

class AltervistaSynonymProvider {
    constructor() {
        this.name = "Altervista";
        this.url = "http://thesaurus.altervista.org/";
        //Look up more later
        this.supportedLanguages = [
            "es",
            "it",
            "fr",
            "de",
        ];
        this.languageCodes = {
            "es": "es_ES",
            "it": "it_IT",
            "fr": "fr_FR",
            "de": "de_DE",
        };
        //This is limited to 5000 queries/day
        this.TOKEN = "P4QAmqYIN1DY6XjlQJht";
        this.API_END_POINT = "https://api.allorigins.win/get?url=" + encodeURIComponent('http://thesaurus.altervista.org/thesaurus/v1');
    }
    requestSynonyms(query, lang, _) {
        return __awaiter(this, void 0, void 0, function* () {
            const synonyms = [];
            let result;
            try {
                result = yield fetch(this.constructRequest(query, lang));
            }
            catch (error) {
                return Promise.reject(error);
            }
            if (result.status != 200) {
                return Promise.reject();
            }
            const json = yield result.json();
            for (const c of JSON.parse(json.contents).response) {
                const words = c.list.synonyms.split('|');
                words.forEach((word) => {
                    synonyms.push({ word: word });
                });
            }
            return synonyms;
        });
    }
    constructRequest(query, lang) {
        return this.API_END_POINT + encodeURIComponent("?word=" + query + "&key=" + this.TOKEN + "&language=" + this.languageCodes[lang] + "&output=json");
    }
}

/*
HOW TO ADD A NEW API:

1. Add a new class that implements DefinitionProvider or
SynonymProvider (or both) and put the file in /src/api/
2. Push the new Provider to the right list in the
APIManager, as seen below
3. Test the Solution
4. Create a new Pull Request on GitHub
*/
class APIManager {
    constructor(settings) {
        // Adds new API's to the Definition Providers
        this.definitionProvider = [
            new FreeDictionaryDefinitionProvider(),
        ];
        // Adds new API's to the Synonym Providers
        this.synonymProvider = [
            new FreeDictionarySynonymProvider(),
            new OpenThesaurusSynonymAPI(),
            new SynonymoSynonymAPI(),
            new AltervistaSynonymProvider(),
        ];
        // Adds new API's to the Part Of Speech Providers
        this.partOfSpeechProvider = [
            new SystranPOSProvider(),
        ];
        this.settings = settings;
    }
    /**
     * Sends a request with the passed query to the chosen API and returns the Result
     *
     * @param query - The term you want to look up
     * @returns The API Response of the chosen API as Promise<DictionaryWord>
     */
    requestDefinitions(query) {
        return this.getDefinitionAPI().requestDefinitions(query, this.settings.defaultLanguage);
    }
    /**
     * Sends a request with the passed query to the chosen API and returns the resulting Synonyms
     *
     * @param query - The term you want to look up
     * @param pos - The part of speech of the target word
     * @returns The API Response of the chosen API as Promise<Synonym[]>
     */
    requestSynonyms(query, pos) {
        return this.getSynonymAPI().requestSynonyms(query, this.settings.defaultLanguage, pos);
    }
    /**
     * Sends a request with the passed word to the chosen API and returns the detected part of speech
     *
     * @param word - The word you want to look up
     * @param leftContext - The sentence content before the word
     * @param rightContext - The sentence content after the word
     * @returns The API Response of the chosen API as Promise<PartOfSpeech>
     */
    requestPartOfSpeech(word, leftContext, rightContext) {
        var _a;
        return (_a = this.getPartOfSpeechAPI()) === null || _a === void 0 ? void 0 : _a.requestPartOfSpeech(word, leftContext, rightContext, this.settings.defaultLanguage);
    }
    /**
     * @returns Returns the currently active Definition API
     */
    getDefinitionAPI() {
        return this.definitionProvider.find((api) => api.name == this.settings.definitionApiName);
    }
    /**
     * @returns Returns the currently active Synonym API
     */
    getSynonymAPI() {
        return this.synonymProvider.find((api) => api.name == this.settings.synonymApiName);
    }
    /**
     * @returns Returns the currently active part of speech API
     */
    getPartOfSpeechAPI() {
        return this.partOfSpeechProvider.find(this.settings.advancedSynonymAnalysis ? (api) => api.name == this.settings.partOfSpeechApiName : null);
    }
}

function fade(node, { delay = 0, duration = 400, easing = identity } = {}) {
    const o = +getComputedStyle(node).opacity;
    return {
        delay,
        duration,
        easing,
        css: t => `opacity: ${t * o}`
    };
}

/* src/ui/synonyms/synonymPopover.svelte generated by Svelte v3.38.2 */

const { document: document_1 } = globals;

function add_css() {
	var style = element("style");
	style.id = "svelte-1j3cg25-style";
	style.textContent = ".dict-s-popover.svelte-1j3cg25.svelte-1j3cg25{min-width:210px;max-width:250px;max-height:200px;background-color:var(--background-primary);border:1px solid var(--background-modifier-border);position:absolute;z-index:var(--layer-popover);border-radius:5px;box-shadow:0px 15px 25px rgba(0, 0, 0, 0.2);font-size:14px;overflow-y:auto;overflow-x:hidden;line-height:1.4}.dict-s-popover__select-option.svelte-1j3cg25.svelte-1j3cg25{cursor:pointer;padding:10px;border-bottom:1px solid var(--background-modifier-border)}.dict-s-popover__select-option.svelte-1j3cg25.svelte-1j3cg25:hover{background-color:var(--background-secondary)}.dict-s-popover.svelte-1j3cg25>.dict-s-popover__select-option.svelte-1j3cg25:last-child{border-bottom:none}.dict-s-popover__select-label.svelte-1j3cg25.svelte-1j3cg25{display:flex;justify-content:space-between;align-items:center}.dict-s-popover__meta-description.svelte-1j3cg25.svelte-1j3cg25,.dict-s-popover__meta-pos.svelte-1j3cg25.svelte-1j3cg25{font-size:12px;color:var(--text-muted)}.dict-s-popover__meta-pos.svelte-1j3cg25.svelte-1j3cg25{display:inline-block;margin-left:10px}";
	append(document_1.head, style);
}

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[6] = list[i];
	return child_ctx;
}

// (39:8) {#if !!synonym.partsOfSpeech?.length}
function create_if_block_1(ctx) {
	let div;
	let t_value = /*synonym*/ ctx[6].partsOfSpeech.join(", ") + "";
	let t;

	return {
		c() {
			div = element("div");
			t = text(t_value);
			attr(div, "class", "dict-s-popover__meta-pos svelte-1j3cg25");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, t);
		},
		p(ctx, dirty) {
			if (dirty & /*synonyms*/ 2 && t_value !== (t_value = /*synonym*/ ctx[6].partsOfSpeech.join(", ") + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

// (43:6) {#if synonym.description}
function create_if_block(ctx) {
	let div;
	let t_value = /*synonym*/ ctx[6].description + "";
	let t;

	return {
		c() {
			div = element("div");
			t = text(t_value);
			attr(div, "class", "dict-s-popover__meta-description svelte-1j3cg25");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, t);
		},
		p(ctx, dirty) {
			if (dirty & /*synonyms*/ 2 && t_value !== (t_value = /*synonym*/ ctx[6].description + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

// (35:2) {#each synonyms as synonym}
function create_each_block(ctx) {
	let div2;
	let div1;
	let div0;
	let t0_value = /*synonym*/ ctx[6].word + "";
	let t0;
	let t1;
	let t2;
	let t3;
	let mounted;
	let dispose;
	let if_block0 = !!/*synonym*/ ctx[6].partsOfSpeech?.length && create_if_block_1(ctx);
	let if_block1 = /*synonym*/ ctx[6].description && create_if_block(ctx);

	function click_handler() {
		return /*click_handler*/ ctx[5](/*synonym*/ ctx[6]);
	}

	return {
		c() {
			div2 = element("div");
			div1 = element("div");
			div0 = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (if_block0) if_block0.c();
			t2 = space();
			if (if_block1) if_block1.c();
			t3 = space();
			attr(div0, "class", "dict-s-popover__term");
			attr(div1, "class", "dict-s-popover__select-label svelte-1j3cg25");
			attr(div2, "class", "dict-s-popover__select-option svelte-1j3cg25");
		},
		m(target, anchor) {
			insert(target, div2, anchor);
			append(div2, div1);
			append(div1, div0);
			append(div0, t0);
			append(div1, t1);
			if (if_block0) if_block0.m(div1, null);
			append(div2, t2);
			if (if_block1) if_block1.m(div2, null);
			append(div2, t3);

			if (!mounted) {
				dispose = listen(div2, "click", click_handler);
				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*synonyms*/ 2 && t0_value !== (t0_value = /*synonym*/ ctx[6].word + "")) set_data(t0, t0_value);

			if (!!/*synonym*/ ctx[6].partsOfSpeech?.length) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_1(ctx);
					if_block0.c();
					if_block0.m(div1, null);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*synonym*/ ctx[6].description) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block(ctx);
					if_block1.c();
					if_block1.m(div2, t3);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}
		},
		d(detaching) {
			if (detaching) detach(div2);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			mounted = false;
			dispose();
		}
	};
}

function create_fragment(ctx) {
	let div;
	let div_intro;
	let mounted;
	let dispose;
	let each_value = /*synonyms*/ ctx[1];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	return {
		c() {
			div = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			set_style(div, "left", /*coords*/ ctx[0].left + "px");
			set_style(div, "top", /*coords*/ ctx[0].bottom + "px");
			attr(div, "class", "dict-s-popover svelte-1j3cg25");
		},
		m(target, anchor) {
			insert(target, div, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div, null);
			}

			if (!mounted) {
				dispose = action_destroyer(/*init*/ ctx[3].call(null, div));
				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (dirty & /*onSelect, synonyms*/ 6) {
				each_value = /*synonyms*/ ctx[1];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}

			if (dirty & /*coords*/ 1) {
				set_style(div, "left", /*coords*/ ctx[0].left + "px");
			}

			if (dirty & /*coords*/ 1) {
				set_style(div, "top", /*coords*/ ctx[0].bottom + "px");
			}
		},
		i(local) {
			if (!div_intro) {
				add_render_callback(() => {
					div_intro = create_in_transition(div, fade, { duration: 50 });
					div_intro.start();
				});
			}
		},
		o: noop,
		d(detaching) {
			if (detaching) detach(div);
			destroy_each(each_blocks, detaching);
			mounted = false;
			dispose();
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	
	
	let { coords } = $$props;
	let { synonyms } = $$props;
	let { onSelect } = $$props;
	let { onClickOutside } = $$props;

	function init(node) {
		// Reposition the popover to fit on screen, if needed
		const height = node.clientHeight;

		const width = node.clientWidth;

		if (coords.bottom + height > window.innerHeight) {
			node.style.setProperty("top", `${coords.top - height}px`);
		}

		if (coords.left + width > window.innerWidth) {
			node.style.setProperty("left", `${window.innerWidth - width - 15}px`);
		}

		// Fire onClickOutside if anything but the popover is clicked
		function onBodyPointerUp(e) {
			if (!node.contains(e.target)) {
				document.body.removeEventListener("pointerup", onBodyPointerUp);
				onClickOutside();
			}
		}

		document.body.addEventListener("pointerup", onBodyPointerUp);
	}

	const click_handler = synonym => onSelect(synonym.word);

	$$self.$$set = $$props => {
		if ("coords" in $$props) $$invalidate(0, coords = $$props.coords);
		if ("synonyms" in $$props) $$invalidate(1, synonyms = $$props.synonyms);
		if ("onSelect" in $$props) $$invalidate(2, onSelect = $$props.onSelect);
		if ("onClickOutside" in $$props) $$invalidate(4, onClickOutside = $$props.onClickOutside);
	};

	return [coords, synonyms, onSelect, init, onClickOutside, click_handler];
}

class SynonymPopover$1 extends SvelteComponent {
	constructor(options) {
		super();
		if (!document_1.getElementById("svelte-1j3cg25-style")) add_css();

		init(this, options, instance, create_fragment, safe_not_equal, {
			coords: 0,
			synonyms: 1,
			onSelect: 2,
			onClickOutside: 4
		});
	}
}

class SynonymPopover {
    constructor(settings) {
        this.isDestroyed = false;
        this.settings = settings;
        this.openSynonymPopover();
    }
    destroy() {
        var _a;
        (_a = this._view) === null || _a === void 0 ? void 0 : _a.$destroy();
        this.isDestroyed = true;
    }
    openSynonymPopover() {
        return __awaiter(this, void 0, void 0, function* () {
            const { cursor, coords, line, selection, apiManager, onSelect } = this.settings;
            const sentences = line.split(/[.!?]/g);
            let seen = 0;
            // Loop through each sentence until we find our target word
            for (const sentence of sentences) {
                if (seen <= cursor.ch && cursor.ch <= seen + sentence.length) {
                    // Split the sentence to get the left and right contexts
                    const before = sentence.substr(0, cursor.ch - seen);
                    const after = sentence.substr(cursor.ch - seen + selection.length);
                    let pos;
                    if (this.settings.advancedPoS) {
                        try {
                            pos = yield apiManager.requestPartOfSpeech(selection, before, after);
                        }
                        catch (e) {
                            console.error(`Error determining part of speech for word ${selection}`, e);
                        }
                    }
                    let synonyms;
                    // Return early if we've been destroyed
                    if (this.isDestroyed)
                        return;
                    try {
                        synonyms = yield apiManager.requestSynonyms(selection, pos);
                    }
                    catch (e) {
                        console.error(`Error requesting synonyms for word ${selection}`, e);
                    }
                    // Return early if we've been destroyed
                    if (this.isDestroyed)
                        return;
                    if (!(synonyms === null || synonyms === void 0 ? void 0 : synonyms.length))
                        return;
                    // Open the synonym popover
                    this._view = new SynonymPopover$1({
                        intro: true,
                        target: document.body,
                        props: {
                            coords,
                            synonyms,
                            onSelect: (selection) => {
                                onSelect(selection);
                                this.destroy();
                            },
                            onClickOutside: () => {
                                this.destroy();
                            }
                        }
                    });
                    break;
                }
                seen += sentence.length + 1;
            }
        });
    }
}

function handleContextMenu(instance, e, plugin) {
    if (!plugin.settings.shouldShowCustomContextMenu) {
        return;
    }
    //prevent opening the default context Menu
    e.preventDefault();
    //"re-add" the default commands for cut, copy and paste
    const fileMenu = new obsidian.Menu(plugin.app);
    if (instance.getSelection()) {
        fileMenu.addItem((item) => {
            item.setTitle(t('Cut'))
                .setIcon('cut')
                .onClick((_) => {
                copy(instance.getSelection());
                instance.replaceSelection("");
            });
        });
        fileMenu.addItem((item) => {
            item.setTitle(t('Copy'))
                .setIcon('copy')
                .onClick((_) => {
                copy(instance.getSelection());
            });
        });
    }
    fileMenu.addItem((item) => {
        item.setTitle(t('Paste'))
            .setIcon('paste')
            .onClick((_) => __awaiter(this, void 0, void 0, function* () {
            instance.replaceSelection(yield navigator.clipboard.readText());
        }));
    });
    //add obsidian dictionary specific commands
    if (instance.getSelection()) {
        fileMenu.addSeparator();
        if (!plugin.settings.shouldShowSynonymPopover) {
            fileMenu.addItem((item) => {
                item.setTitle(t('Show Synonyms'))
                    .setIcon('synonyms')
                    .onClick((_) => __awaiter(this, void 0, void 0, function* () {
                    plugin.handlePointerUp();
                }));
            });
        }
        fileMenu.addItem((item) => {
            item.setTitle(t('Look up'))
                .setIcon('quote-glyph')
                .onClick((_) => __awaiter(this, void 0, void 0, function* () {
                let leaf = plugin.app.workspace.getLeavesOfType(VIEW_TYPE).first();
                if (!leaf) {
                    leaf = plugin.app.workspace.getRightLeaf(false);
                    yield leaf.setViewState({
                        type: VIEW_TYPE,
                    });
                }
                // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                //@ts-ignore
                leaf.view.query(instance.getSelection());
                plugin.app.workspace.revealLeaf(leaf);
            }));
        });
    }
    fileMenu.showAtPosition({ x: e.clientX, y: e.clientY });
}
function copy(string) {
    navigator.clipboard.writeText(string);
}

const icons = {
    synonyms: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" fill-opacity="0.0" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-book-open"><path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"></path><path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"></path></svg>`,
    copy: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" fill-opacity="0.0" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-copy"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>`,
    cut: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" fill-opacity="0.0" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-scissors"><circle cx="6" cy="6" r="3"></circle><circle cx="6" cy="18" r="3"></circle><line x1="20" y1="4" x2="8.12" y2="15.88"></line><line x1="14.47" y1="14.48" x2="20" y2="20"></line><line x1="8.12" y1="8.12" x2="12" y2="12"></line></svg>`,
    paste: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" fill-opacity="0.0" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-clipboard"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></svg>`,
};
const addIcons = () => {
    Object.keys(icons).forEach((key) => {
        obsidian.addIcon(key, icons[key]);
    });
};

//This really needs a refactor
class LocalDictionaryBuilder {
    constructor(plugin) {
        this.plugin = plugin;
        this.settings = plugin.settings;
    }
    cap(string) {
        const words = string.split(" ");
        return words.map((word) => {
            return word[0].toUpperCase() + word.substring(1);
        }).join(" ");
    }
    newNote(content) {
        return __awaiter(this, void 0, void 0, function* () {
            const { plugin, settings } = this;
            let phonetics = '';
            content.phonetics.forEach((value, i, a) => {
                phonetics += '- ' + value.text;
                if (i != a.length - 1) {
                    phonetics += '\n';
                }
            });
            let meanings = '';
            content.meanings.forEach((value) => {
                meanings += '### ' + this.cap(value.partOfSpeech) + '\n\n';
                value.definitions.forEach((def, j, b) => {
                    meanings += def.definition + '\n\n';
                    if (def.example) {
                        meanings += '> ' + def.example + '\n\n';
                    }
                    if (def.synonyms && def.synonyms.length != 0) {
                        def.synonyms.forEach((syn, i, a) => {
                            meanings += syn;
                            if (i != a.length - 1) {
                                meanings += ', ';
                            }
                        });
                        meanings += '\n\n';
                    }
                    if (j != b.length - 1) {
                        meanings += '---\n\n';
                    }
                });
            });
            let file;
            try {
                file = yield plugin.app.vault.create(`${settings.folder ? settings.folder + '/' : ''}${settings.prefix}${settings.capitalizedFileName ? this.cap(content.word) : content.word}${settings.suffix}.md`, settings.template
                    .replace('{{notice}}', t('Autogenerated by Obsidian Dictionary Plugin'))
                    .replace('{{word}}', settings.capitalizedFileName ? this.cap(content.word) : content.word)
                    .replace('{{pronunciationHeader}}', t('Pronunciation'))
                    .replace('{{phoneticList}}', phonetics)
                    .replace('{{meaningHeader}}', t('Meanings'))
                    .replace('{{meanings}}', meanings));
                const leaf = plugin.app.workspace.splitActiveLeaf();
                leaf.openFile(file);
                plugin.app.workspace.setActiveLeaf(leaf);
            }
            catch (error) {
                console.error(error);
                new obsidian.Notice(error);
            }
        });
    }
}

class DictionaryPlugin extends obsidian.Plugin {
    constructor() {
        super(...arguments);
        this.synonymPopover = null;
        this.menus = [
            {
                pluginName: this.manifest.id,
                name: t('Show Synonyms'),
                icon: 'synonyms',
                onClick: (instance) => {
                    if (instance.getSelection()) {
                        this.handlePointerUp();
                    }
                },
                enabled: true,
            },
            {
                pluginName: this.manifest.id,
                name: t('Look up'),
                icon: 'quote-glyph',
                onClick: (instance) => __awaiter(this, void 0, void 0, function* () {
                    if (instance.getSelection()) {
                        let leaf = this.app.workspace.getLeavesOfType(VIEW_TYPE).first();
                        if (!leaf) {
                            leaf = this.app.workspace.getRightLeaf(false);
                            yield leaf.setViewState({
                                type: VIEW_TYPE,
                            });
                        }
                        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                        //@ts-ignore
                        leaf.view.query(instance.getSelection());
                        this.app.workspace.revealLeaf(leaf);
                    }
                }),
                enabled: true,
            },
        ];
        this.contextMenuLoader = (instance, e) => {
            this.handlePointerUp.cancel();
            handleContextMenu(instance, e, this);
        };
        // Open the synonym popover if a word is selected
        // This is debounced to handle double clicks
        this.handlePointerUp = obsidian.debounce(() => {
            const activeLeaf = this.app.workspace.activeLeaf;
            if ((activeLeaf === null || activeLeaf === void 0 ? void 0 : activeLeaf.view) instanceof obsidian.MarkdownView) {
                const view = activeLeaf.view;
                if (view.getMode() === 'source') {
                    const editor = view.editor;
                    const selection = editor.getSelection();
                    // Return early if we don't have anything selected, or if
                    // multiple words are selected
                    if (!selection || /\s/.test(selection))
                        return;
                    const cursor = editor.getCursor('from');
                    const line = editor.getLine(cursor.line);
                    let coords;
                    // Get the cursor position using the appropriate CM5 or CM6 interface
                    if (editor.cursorCoords) {
                        coords = editor.cursorCoords(true, 'window');
                    }
                    else if (editor.coordsAtPos) {
                        const offset = editor.posToOffset(cursor);
                        coords = editor.coordsAtPos(offset);
                    }
                    else {
                        return;
                    }
                    this.synonymPopover = new SynonymPopover({
                        apiManager: this.manager,
                        advancedPoS: this.settings.advancedSynonymAnalysis,
                        coords,
                        cursor,
                        line,
                        selection,
                        onSelect: (replacement) => {
                            editor.replaceSelection(matchCasing(replacement, selection));
                        }
                    });
                }
            }
        }, 300, true);
    }
    onload() {
        return __awaiter(this, void 0, void 0, function* () {
            console.log('loading dictionary');
            yield this.loadSettings();
            addIcons();
            this.addSettingTab(new SettingsTab(this.app, this));
            this.manager = new APIManager(this.settings);
            this.registerView(VIEW_TYPE, (leaf) => {
                return new DictionaryView(leaf, this);
            });
            this.addCommand({
                id: 'dictionary-open-view',
                name: t('Open Dictionary View'),
                callback: () => __awaiter(this, void 0, void 0, function* () {
                    if (this.app.workspace.getLeavesOfType(VIEW_TYPE).length == 0) {
                        yield this.app.workspace.getRightLeaf(false).setViewState({
                            type: VIEW_TYPE,
                        });
                    }
                    this.app.workspace.revealLeaf(this.app.workspace.getLeavesOfType(VIEW_TYPE).first());
                }),
            });
            this.addCommand({
                id: 'dictionary-open-language-switcher',
                name: t('Open Language Switcher'),
                callback: () => {
                    new LanguageChooser(this.app, this).open();
                },
            });
            this.registerDomEvent(document.body, "pointerup", () => {
                if (!this.settings.shouldShowSynonymPopover) {
                    return;
                }
                this.handlePointerUp();
            });
            this.registerDomEvent(window, "keydown", () => {
                // Destroy the popover if it's open
                if (this.synonymPopover) {
                    this.synonymPopover.destroy();
                    this.synonymPopover = null;
                }
            });
            this.localDictionary = new LocalDictionaryBuilder(this);
            this.app.workspace.onLayoutReady(() => {
                //@ts-ignore
                const extendedContextMenu = this.app.plugins.getPlugin("extended-context-menu");
                if (extendedContextMenu) {
                    this.menus.forEach((menu) => {
                        extendedContextMenu.registerCommand(menu);
                    });
                }
                else {
                    //Create a new Custom Context Menu on right click inside the Editor
                    this.registerCodeMirror(cm => {
                        cm.on('contextmenu', this.contextMenuLoader);
                    });
                }
            });
        });
    }
    onunload() {
        console.log('unloading dictionary');
        //@ts-ignore
        const extendedContextMenu = this.app.plugins.getPlugin("extended-context-menu");
        if (extendedContextMenu) {
            this.menus.forEach((menu) => {
                extendedContextMenu.unregisterCommand(menu);
            });
        }
        else {
            this.app.workspace.iterateCodeMirrors((cm) => {
                cm.off("contextmenu", this.contextMenuLoader);
            });
        }
    }
    loadSettings() {
        return __awaiter(this, void 0, void 0, function* () {
            this.settings = Object.assign({}, DEFAULT_SETTINGS, yield this.loadData());
        });
    }
    saveSettings() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.saveData(this.settings);
        });
    }
}

module.exports = DictionaryPlugin;
//# sourceMappingURL=main.js.map
